## 1、项目准备

下载模板后，先 **npm install** 初始化依赖包，如果报错，再安装**最新版本core-js即可解决**

#### 1.文件夹认知

build   index.js  webpack配置文件【很少去修改这个文件】

mock   mock数据的文件夹【模拟一些假的数据mockjs实现】，实例开发用的真实接口

node_modules   项目依赖的模块

`public   icon图标，静态页面，经常放置一些静态资源，在项目打包的时候webpack不会编译，会原封不动的打包到dist文件夹中`

src文件夹

   ---程序员代码的地方

api 文件夹：涉及请求相关的

assets  里面放置一些静态资源（一般共享的），放在assets文件中的资源打包的时候会进行编译

components文件夹：一般放置非路由组件或全局组件

icons文件里面放置一些svg矢量图

layout文件夹：放置一些组件和混入（将重复的js代码进行封装后引入使用）

router文件夹：与路由注册配置相关的

store文件夹：与vuex相关的

style文件夹：与样式相关的

utils文件夹：requests对axios二次封装的

views文件交接：里面放置的是路由组件



App.vue 跟组件

main.js  入口文件

permission.js   与导航守卫相关，有token去login不行，去其他页面可以，但需要先判断是否有用户信息，没有获取完再放行，如果token过去移出后，针对没有token的情况如何处理

settings  项目配置项文件 `可修改网页标题`等    title: '商品管理系统',

.env.development  开发环境配置文件

.env.production  上线生产环境配置文件

.env.staging  测试环境配置文件   webpack打包的时候可以检测到所处环境，里面有baseURL

#### 2.elementUI配置

Element 组件内部默认`使用中文`，若希望使用其他语言，则需要进行多语言设置。以英文为例，在 main.js 中：

```js
// 完整引入 Element
import Vue from 'vue'
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
import locale from 'element-ui/lib/locale/lang/en'// 使用英文

// 中文版 element-ui，声明方式
Vue.use(ElementUI)
// 英文版 声明方式
Vue.use(ElementUI, { locale })
```

#### 3.Element-ui和Element-Plus的区别

一、定义区别

Element-UI对应Element2：**基本不支持手机版**

> Element，一套为开发者、设计师和产品经理准备的基于 **Vue 2.0** 的桌面端组件库

Element-Plus对应Element3：组件布局考虑了手机版展示

> 基于 **Vue 3**，面向设计师和开发者的组件库

二、框架区别

​		Element-ui适用于Vue2框架

​		Element-plus适用于Vue3框架

三、开发中使用的区别

 1.Icon图标库变化了

新版本的图标库使用方式

```js
<template>
  <div>
    <el-icon :size="size" :color="color">
      <edit></edit>
    </el-icon>
    <!-- Or use it independently without derive attributes from parent -->
    <edit></edit>
<el-icon><copy-document /></el-icon>
  </div>
</template>
```

2.组件的插槽slot使用变化了

同时可支持多个插槽

```js
<el-autocomplete popper-class="my-autocomplete" v-model="state" :fetch-suggestions="querySearch" placeholder="请输入内容" @select="handleSelect" >
     <template #suffix>
          <i class="el-icon-edit el-input__icon" @click="handleIconClick"> </i> 
     </template>
     <template #default="{ item }">
          <div class="name">{{ item.value }}</div>
          <span class="addr">{{ item.address }}</span>
     </template>
 </el-autocomplete>
```

3.新增组件

- Skeleton-骨架屏
- Empty-空状态
- Affix -固钉
- TimeSelect 时间选择
- Space 间距



## 2、登录退出业务

#### 1.登录业务

（1）完成静态页面（修改背景图为图片，设置图片size为100%）

```js
 <!-- el-form组件：elementUI插件里面的一个组件，经常展示表单元素 model：用于收集表单数据  rules：表单验证规则 -->
    <el-form
      ref="loginForm"
      :model="loginForm"
      :rules="loginRules"
      class="login-form"
      auto-complete="on"
      label-position="left"
    >
    
 // 设置背景图，路径前加~  尺寸100%
  background: url(~@/assets/1.png);
  background-size: 100% auto;
```

（2）分析登录的回调

 this.$router.push({ path: this.redirect || '/' })这样写会报错，直接push到首页，`this.$router.push('/')`

```js
 // 登录业务：发请求，带用户名与密码给服务器（成功或失败）
    handleLogin() {
      // 这里在验证表单元素（用户名与密码）是否符合规则
      this.$refs.loginForm.validate((valid) => {
        // 如果符合验证规则
        if (valid) {
          // 按钮会有一个loading效果
          this.loading = true
          // 派发action，带着用户名与密码载荷
          this.$store
            .dispatch('user/login', this.loginForm)
            .then(() => {
              // 登录成功进行路由跳转
              this.$router.push('/')
              // loading效果结束
              this.loading = false
            })
            .catch(() => {
              this.loading = false
            })
        } else {
          console.log('error submit!!')
          return false
        }
      })
    },
```

（3）登录业务的actions

```js
// 登录业务
  async login({ commit }, userInfo) {
    // 解构用户名与密码
    const { username, password } = userInfo
    let result = await login({ username: username.trim(), password: password })
    if (result.code === 20000) {
      // 成功提交mutation,持久化存储token
      commit('SET_TOKEN', result.data.token)
      setToken(result.data.token)
      return 'ok'
    } else {
      // 失败
      return Promise.reject(new Error('faile'))
    }
  },
```

（3）书写API，改成真实的登录接口（api----user.js）

```js
// 登录接口
export function login(data) {
  return request({
    url: '/admin/acl/index/login',
    method: 'post',
    data
  })
}

// 获取用户信息
export function getInfo(token) {
  return request({
    url: '/admin/acl/index/info',
    method: 'get',
    params: { token }
  })
}

// 退出登录
export function logout() {
  return request({
    url: '/admin/acl/index/logout',
    method: 'post'
  })
}
```

（4）解决代理跨域问题，`vue.config.js`中书写

```js
 // 配置代理跨域
    proxy: {
      '/dev-api': {
        target: 'http://gmall-h5-api.atguigu.cn:8170', // 真正要访问的地址
        pathRewrite: { '^/dev-api': '' } // 重写路径，去掉前缀
      }
    }
```

#### 2.退出业务

去layout---components--NavBar里面配置

```js
<el-dropdown-menu slot="dropdown" class="user-dropdown">
          <router-link to="/">
            <el-dropdown-item style="font-weight: 600">{{
              username
            }}</el-dropdown-item>
          </router-link>
          <el-dropdown-item divided @click.native="logout">
            <span style="display: block; text-align: center">退出</span>
          </el-dropdown-item>
        </el-dropdown-menu>
      </el-dropdown>
          
// 退出登录
    async logout() {
      await this.$store.dispatch('user/logout')
      this.$router.push(`/login?redirect=${this.$route.fullPath}`)
    },
        
 computed: {
    ...mapGetters(['sidebar', 'avatar']),
    // 获取用户名
    username() {
      return localStorage.getItem('TOKEN')
    },
  },
```

## 3、路由搭建

商品管理下设4个二级分类，先创建组件，再配置路由

```js
 {
    path: '/product',
    component: Layout,
    name: 'Product',
    meta: { title: '商品管理', icon: 'el-icon-goods' },
    children: [
      {
        path: 'trademark',
        name: 'TradeMark',
        component: () => import('@/views/product/tradeMark'),
        // 设置在侧边栏展示的文字
        meta: { title: '品牌管理' }
      },
      {
        path: 'attr',
        name: 'Attr',
        component: () => import('@/views/product/Attr'),
        // 设置在侧边栏展示的文字
        meta: { title: '平台属性管理' }
      },
      {
        path: 'spu',
        name: 'Spu',
        component: () => import('@/views/product/Spu'),
        // 设置在侧边栏展示的文字
        meta: { title: 'Spu管理' }
      },
      {
        path: 'sku',
        name: 'Sku',
        component: () => import('@/views/product/Sku'),
        // 设置在侧边栏展示的文字
        meta: { title: 'Sku管理' }
      }
    ]
  },
```

## 4、tradeMark品牌管理组件

#### 1.静态页面

（1）添加按钮

```js
<!-- 按钮 -->
   <el-button   type="primary"   icon="el-icon-plus"   style="margin: 10px auto"
      @click="showDialog"
      >添加</el-button>
```

（2）表格组件

```js
<!-- 表格组件
    data:表格组件将来需要展示的数据---数据类型
    border：给表格添加边框
    column：是一列一列展示的
    label:显示的标题
    width:对应列的宽度
    align:标题对齐方式
    -->
    <el-table border="true" style="width: 100%">
      <el-table-column label="序号" width="80px" align="center" />
      <el-table-column label="品牌名称" />
      <el-table-column label="品牌LOGO" />
      <el-table-column label="操作" />
    </el-table>
```

（3）分页器

重要数据：当前第几页，数据总条数、每一页展示条数 连续页码数据（注意：`分页器居中行内样式写法：text-align: center`）

-    @current-change=""  currentPage 改变时会触发
-    @size-change=''''   pageSize 改变时会触发
-    layout：组件布局，子组件名用逗号分隔,加个箭头，让后面的子组件可以靠右展示
-    current-page：当前第几页
-    total：代表分业务一共需要展示数据条数
-    page-size：每一页展示条数
-    page-sizes：可以设置每一页展示多少条数据
-    layout：实现分页器布局
-    pager-count：页码按钮的数量，减去2就是连续页码数

```js
<el-pagination
      style="text-align: center; margin-top: 20px"
      :total="99"
      :current-page="6"
      :page-size="3"
      :pager-count="7"
      :page-sizes="[3, 5, 10]"
      layout="prev, pager, next, jumper, ->,sizes,total"
    />
```

#### 2.获取动态数据

书写品牌管理相关的接口并再main.js中统一引入，挂在原型上方便其他组件使用

```js
// 获取品牌列表接口

//  GET /admin/product/baseTrademark/{page}/{limit}

export const reqTradeMarkList = (page, limit) => request({ url: `/admin/product/baseTrademark/${page}/${limit}`, method: 'get' })
```

```js
// main.js引入相关API请求接口
import API from '@/api/index'
// 组件实例的原型的原型指向的是Vue.prototype
// 任意组件都可以使用api相关的接口
Vue.prototype.$API = API
```

#### 3.动态展示数据

```js
<el-table border style="width: 100%" :data="list" size="mini">
      <el-table-column label="序号" width="80px" align="center" type="index" />
      <el-table-column label="品牌名称" prop="tmName" />
      <el-table-column label="品牌LOGO" prop="logoUrl">
        <!-- 展示图片如果直接写，只能显示地址，使用作用域插槽展示为图片 -->
        <template slot-scope="{ row, $index }">
          <img :src="row.logoUrl" style="height: 100px; width: 100px" />
        </template>
      </el-table-column>
      <el-table-column label="操作">
        <template slot-scope="{ row, $index }">
          <el-button
            type="warning"
            icon="el-icon-edit"
            size="mini"
            @click="updateTradeMark(row)"
            >修改</el-button
          >
          <el-button type="danger" icon="el-icon-delete" size="mini"
            >删除</el-button
          >
        </template>
      </el-table-column>
    </el-table>
```

#### 4.当前页码变化时触发的回调

第一种写法

```js
@current-change="handleCurrentChange"

// 当前页码变化时触发
    handleCurrentChange(pager) {
      console.log(pager)
      // 修改当前页码，重新获取数据
      this.page = pager
      this.getPageList()
    },
```

第二种写法：获取列表和当前页码改变就可以通过1个函数来实现了

```js
@current-change="getPageList"

// 获取品牌列表的数据(默认值1，点击分页器时会自动传入当前点击的页码数)
    async getPageList(pager = 1) {
      this.page = pager
      // 解构出参数
      const { page, limit } = this
      // 获取品牌列表的接口(需要带参数  page limit)
      const result = await this.$API.trademark.reqTradeMarkList(page, limit)
      console.log(result)
      if (result.code === 200) {
        this.total = result.data.total
        this.list = result.data.records
      }
    },
```

#### 5.每页展示条数发生变化触发的回调

```js
 @size-change="handleSizeChange"
 
 // 当分页器某一页展示数据条数发生变化时触发
    handleSizeChange(size) {
      this.limit = size
      this.getPageList()
    },
```

#### 6.添加品牌对话框静态

对话框内嵌form表单，然后放两个form-item，第一个里面是普通的文本框，第二个是图片上传的元素（从elementUI上找类似的直接复制即可，记得带样式复制，关于图片大小的配置在第8点）

```js
 <!-- 添加的对话框
    :visible.sync：控制对话框显示与隐藏用的-->
    <el-dialog title="添加品牌" :visible.sync="dialogFormVisible">
      <!-- form表单 -->
      <el-form style="width: 80%">
        <el-form-item label="品牌名称" label-width="100px">
          <el-input autocomplete="off" />
        </el-form-item>
        <el-form-item label="品牌LOGO" label-width="100px">
          <!--
            :on-success="handleAvatarSuccess"
            :before-upload="beforeAvatarUpload"
           -->
          <el-upload
            class="avatar-uploader"
            action="https://jsonplaceholder.typicode.com/posts/"
            :show-file-list="false"
          >
            <img v-if="imageUrl" :src="imageUrl" class="avatar" />
            <i v-else class="el-icon-plus avatar-uploader-icon" />
            <div slot="tip" class="el-upload__tip">
              只能上传jpg/png文件，且不超过500kb
            </div>
          </el-upload>
        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button @click="dialogFormVisible = false">取 消</el-button>
        <el-button type="primary" @click="dialogFormVisible = false"
          >确 定</el-button
        >
      </div>
    </el-dialog>
```

#### 7.显示对话框的回调

点击添加或修改按钮后，对话框的显示属性 `dialogFormVisible  为true`，分开创建后期方便对dialog对话框做做不同逻辑的处理，添加需要清除所有数据，而修改则需要先获取数据展示出来再修改

```js
	// 点击添加品牌的按钮
    showDialog() {
      // 显示对话框
      this.dialogFormVisible = true
    },
    // 修改品牌的回调
    updateTradeMark() {
      // 显示对话框
      this.dialogFormVisible = true
    },
```

#### 8.添加品牌

（1）添加品牌按钮的回调

```js
// 点击添加品牌的按钮
    showDialog() {
      // 显示对话框
      this.dialogFormVisible = true
      // 清除之前的数据
      this.tmForm = {
        tmName: '',
        logoUrl: '',
      }
```

（2）添加|修改品牌的接口在一个请求里发

```js
// 新增品牌的接口
// url: /admin/product/baseTrademark/save   POST   携带参数  logoUrl   tmName   不需要带ID ID是由服务器生成的

// 修改品牌的接口
//  url:/admin/product/baseTrademark/update   PUT   参数 id 品牌名称 品牌logo
// （修改品牌，需要告诉服务器要改哪个，所以需要带id）
export const reqAddOrUpdateTradeMark = (tradeMark) => {
  // 如果有id就是修改品牌
  if (tradeMark.id) {
    return request({
      url: `/admin/product/baseTrademark/update`,
      method: 'put',
      data: tradeMark
    })
  } else {
    // 新增品牌
    return request({
      url: '/admin/product/baseTrademark/save',
      method: 'post',
      data: tradeMark
    })
  }
}
```

（3）收集表单数据和图片地址

整个form表单使用model（表单数据对象,将数据收集到哪个对象身上，将来表单验证也需要这个属性）收集数据，里面的每一项再.属性取出来即可，但需要注意图片地址，是一个上传图片的插件,不是什么表单元素,不能使用v-model来收集数据，`要用:src`
 action：设置图片上传的地址，修改为项目的地址：`/admin/product/fileUpload`，记得加前缀`/dev-api`，不然不转发给代理服务器
:on-success="handleAvatarSuccess" :检测到图片上传成功，当图片上传成功会执行一次
:before-upload="beforeAvatarUpload" ：可以在图片上传之前执行一次

```js
<el-form style="width: 80%" :model="tmForm">
        <el-form-item label="品牌名称" label-width="100px">
          <el-input v-model="tmForm.tmName" autocomplete="off" />
        </el-form-item>
        <el-form-item label="品牌LOGO" label-width="100px">
          <el-upload
            class="avatar-uploader"
            action="/dev-api/admin/product/fileUpload"
            :show-file-list="false"
            :on-success="handleAvatarSuccess"
            :before-upload="beforeAvatarUpload"
          >
            <img v-if="tmForm.logoUrl" :src="tmForm.logoUrl" class="avatar" />
            ······
          </el-upload>
        </el-form-item>
      </el-form>
```

#### 9.图片上传相关的回调**

```js
// 图片上传成功
    handleAvatarSuccess(res, file) {
      // res:上传成功之前返回给前端的数据，包含图片的地址
      // file：上传成之后服务器返回给前端的数据对象
      // 收集品牌图片的数据，
      this.tmForm.logoUrl = res.data
    },
    // 图片上传之前:只能传jpg|| png 格式且不能大于500kb
    beforeAvatarUpload(file) {
      const isJPG = file.type === 'image/jpeg'
      const isPNG = file.type === 'image/png'
      const max = 500 / 1024
      const isLt2M = file.size / 1024 / 1024 < max

      if (!isJPG && !isPNG) {
        this.$message.error('上传图片只能是 JPG或PNG 格式!')
      }
      if (!isLt2M) {
        this.$message.error('上传图片大小不能超过 500kb !')
      }
      return (isJPG || isPNG) && isLt2M
    },
```

#### 10.修改品牌

由于添加品牌和修改品牌用的是一个请求函数，通过是否有id做区分，所以对话框的标题和通知框的提示均可通过三元表达式进行动态展示，注意两者用的是同一个对话框，对话框中的确定回调写一个就行

（1）修改品牌按钮的回调

```js
 <el-button
            type="warning"
            icon="el-icon-edit"
            size="mini"
            @click="updateTradeMark(row)"
            >修改</el-button
          >
// 修改品牌按钮的回调
    updateTradeMark(row) {
      // row :当前用户选择的品牌信息（id logoUrl tmName）
      // 显示对话框
      this.dialogFormVisible = true
      // 将服务器返回的品牌信息赋值给tmForm进行展示，tmForm也就是存储的服务器返回的品牌信息
      // 所以需要使用浅拷贝,tmForm和服务器返回的是两个单独的数据，
      this.tmForm = { ...row }
    },

```

（2）对话框确定按钮的回调

> **如果添加品牌，添加完停留在第一页，修改品牌修改完应该停在在当前页面**

```js
 // 对话框中的确定添加按钮（添加品牌 | 修改品牌）
    addOrUpdateTradeMark() {
      // 当全部表单验证完毕后再去书写逻辑
      this.$refs.ruleForm.validate(async (success) => {
        // 如果字段全部验证成功
        if (success) {
          // 第一步：隐藏对话框
          this.dialogFormVisible = false
          // 第二步：发请求
          const result = await this.$API.trademark.reqAddOrUpdateTradeMark(
            this.tmForm
          )
          // 添加成功干什么
          if (result.code === 200) {
            // 弹出提示信息：添加/修改品牌成功
            const message = this.tmForm.id ? '修改品牌成功' : '添加品牌成功'
            this.$message({
              message: message,
              type: 'success',
            })
            // 重新获取品牌列表
            // 如果添加品牌：停留在第一页，修改品牌应该停在在当前页面
            this.getPageList(this.tmForm.id ? this.page : 1)
          }
        } else {
          console.log('提交失败')
        }
      })
    },
```

#### 11.表单rules验证

elementUI中的Form 组件提供了表单验证的功能，只需要通过 `rules 属性`传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。

（1）form打ref标识,item分配prop

```js
 <el-form ref="ruleForm" style="width: 80%" :model="tmForm" :rules="rules">
        <el-form-item label="品牌名称" label-width="100px" prop="tmName">
          <el-input v-model="tmForm.tmName" autocomplete="off" />
        </el-form-item>
        <el-form-item label="品牌LOGO" label-width="100px" prop="logoUrl">
        </el-form-item>
</el-form>
```

（2）书写校验规则rules

```js
 data() { 
     // 对话框中表单的验证规则
      rules: {
        // 品牌名称的验证规则
        // required:必须要校验字段（带星号）  trigger 用户行为设置（事件的设置  blur change）
        tmName: [
          { required: true, message: '请输入品牌名称', trigger: 'blur' },---不输入触发
          // 品牌名称长度2-10
          {
            min: 2,
            max: 10,
            message: '长度在 2 到 10 个字符',
            trigger: 'change',——只要有输入
          },
        ],
        // 品牌的logo验证规则
        logoUrl: [{ required: true, message: '请选择品牌图片' }],
      },
 }
```

（3）表单验证

```js
// 确定添加按钮（添加品牌 | 修改品牌）
    addOrUpdateTradeMark() {
      // 当全部表单验证完毕后再去书写逻辑。form身上自带validate可以进行表单验证
      this.$refs.ruleForm.validate(async (success) => {
        // 如果字段全部验证成功
        if (success) {
          // 第一步：隐藏对话框
          this.dialogFormVisible = false
          // 第二步：发请求
          const result = await this.$API.trademark.reqAddOrUpdateTradeMark(
            this.tmForm
          )
          // 添加成功干什么
          ·······
        } else {
          console.log('提交失败')
        }
      })
    },
```

#### 12.自定义校验规则**

自定义规则写法相对复杂，可以在规则里加入更多逻辑判断，符合条件即可放行，切记：`callback函数必须调用`

```js
 data() {  
 	// 自定义校验规则
    var validatetmName = (rule, value, callback) => {
      // value长度在2-10之间
      if (value.length < 2 || value.length > 10) {
        callback(new Error('长度在 2 到 10 个字符'))
      } else {
        callback()
      }
    }
    
    
    // 对话框中表单的验证规则
      rules: {
        // 品牌名称的验证规则
        // required:必须要校验字段（带星号）  trigger 用户行为设置（事件的设置  blur change）
        tmName: [
          { required: true, message: '请输入品牌名称', trigger: 'blur' },
          { validator: validatetmName, trigger: 'change' },
        ], 
 }
```

#### 12.删除品牌

（1）删除品牌接口

```js
// 删除品牌
//  DELETE /admin/product/baseTrademark/remove/{id}
export const reqDeleteTradeMark = (id) => request({
  url: `/admin/product/baseTrademark/remove/${id}`,
  method: 'delete'
})
```

（2）删除按钮的回调

```js
<el-button  type="danger"   icon="el-icon-delete"
size="mini"   @click="deleteTradeMark(row)">删除</el-button>
```

（3）引入MessageBox 弹框

模拟系统的消息提示框而实现的一套模态对话框组件，用于消息提示、确认消息和提交内容。

```js
// 删除品牌的回调
    deleteTradeMark(row) {
      this.$confirm(`你确定删除${row.tmName}品牌？`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      }).then(async () => {
          // 点击确定按钮触发
          ······
        })
        .catch(() => {
          // 点击取消按钮触发
          this.$message({
            type: 'info',
            message: '已取消删除',
          })
        })
    },
```

（4）确定删除业务

删除成功message提示用户并再次获取品牌列表数据，**注意：如果当前页面元素大于1，删除之后还留在当前页，否则应该留到当前页的前一页**

```js
// 点击确定按钮触发
          // 向服务器发请求
          const result = await this.$API.trademark.reqDeleteTradeMark(row.id)
          if (result.code === 200) {
            // 提示成功
            this.$message({
              type: 'success',
              message: '删除成功!',
            })
            // 再次发请求获取品牌数据
            // 注意:需要判断list数组长度,如果长度大于1,留在当前页,否则应该回到前一页
            this.getPageList(this.list.length > 1 ? this.page : this.page - 1)
          }
```

## 5、Attr平台属性管理

#### 1.三级分类联动静态CategorySelect

（1）搭建静态：使用cart卡片，内嵌行内form来实现上部分布局

```js
<el-card style="margin: 20px auto;padding-bottom:-10px">
      <CategorySelect :show="!isShowTable" @getCategoryId="getCategoryId" />
</el-card>

// CategorySelect结构
<!-- 设置 inline 属性可以让表单域变为行内的表单域 -->
<el-form :inline="true" class="demo-form-inline" :model="cForm">
    <el-form-item label="一级分类">
    </el-form-item>
    <el-form-item label="二级分类">
    </el-form-item>
    <el-form-item label="三级分类">
    </el-form-item>
</el-form>
```

（2）写接口--一二三级的都要写

```js
// 获取一级分类数据
//   GET /admin/product/getCategory1
export const reqCategory1List = () => request({
  url: '/admin/product/getCategory1',
  method: 'get'
})

// 获取二级分类数据
// /admin/product/getCategory2/{category1Id}  get
export const reqCategory2List = (category1Id) => request({
  url: `/admin/product/getCategory2/${category1Id}`,
  method: 'get'
})

// 获取三级分类数据
// /admin/product/getCategory3/{category2Id}   get
export const reqCategory3List = (category2Id) => request({
  url: `/admin/product/getCategory3/${category2Id}`,
  method: 'get'
})
```

（3）一级数据与静态

组件挂载就要获取一级分类数据，当一级变化时去获取二级数据，当二级变化时去获取三级数据，后面是一环套一环的。注意：这里需要给最外层的form绑定：model = 'cForm' ，里面的select再去绑定cForm里面相应的分类id

```js
// 组件挂载完毕:向服务器发请求,获取一级分类的数据
  mounted() {
    // 获取一级分类的数据
    this.getCategory1List()
  },
  methods: {
    // 获取一级分类数据
    async getCategory1List() {
      // 不用携带参数
      const result = await this.$API.attr.reqCategory1List()
      if (result.code === 200) {
        this.list1 = result.data
      }
    },
  }


// 遍历生成静态
 <el-form-item label="一级分类">
        <!-- 给一级分类下拉框绑定数据和事件 -->
        <el-select
          v-model="cForm.category1Id"
          placeholder="请选择"
          @change="handler1"
        >
          <el-option
            v-for="(c1, index) in list1"
            :key="c1.id"
            :label="c1.name"
            :value="c1.id"
          />
        </el-select>
      </el-form-item>
```

（4）二级数据与静态--当一级分类下拉框变化时去获取

```js
// 一级分类select事件回调(当一级分类的option发生变化时去获取相应的二级分类的数据)
    async handler1() {
      // 解构出一级分类的id
      const { category1Id } = this.cForm
      // 通过一级分类id 获取二级分类的数据
      const result = await this.$API.attr.reqCategory2List(category1Id)
      if (result.code === 200) {
        this.list2 = result.data
      }
    },
        
 // 根据list2去遍历生成二级分类
 <el-form-item label="二级分类">
        <!-- 将:value="c2.id" 收集到 v-model="cForm.category2Id" -->
        <el-select
          v-model="cForm.category2Id"
          placeholder="请选择"
          @change="handler2"
        >
          <el-option
            v-for="(c2, index) in list2"
            :key="c2.id"
            :label="c2.name"
            :value="c2.id"
          />
        </el-select>
      </el-form-item>       
```

（5）三级数据与静态

```js
// 二级分类select事件回调(当二级分类的option发生变化时去获取相应的三级分类的数据)
    async handler2() {
      // 解构出二级分类的id
      const { category2Id } = this.cForm
      // 通过二级分类id 获取三级分类的数据
      const result = await this.$API.attr.reqCategory3List(category2Id)
      if (result.code === 200) {
        this.list3 = result.data
      }
    },	

// 根据list3去遍历生成三级分类
  <el-form-item label="三级分类">
        <el-select
          v-model="cForm.category3Id"
          placeholder="请选择"
          @change="handler3"
        >
          <el-option
            v-for="(c3, index) in list3"
            :key="c3.id"
            :label="c3.name"
            :value="c3.id"
          />
        </el-select>
      </el-form-item>
```

（6）当一级分类变化时`清空二三级数据`，当二级分类变化时`清空三级数据`

```js
// 一级分类select事件回调(当一级分类的option发生变化时去获取相应的二级分类的数据)
    async handler1() {
      // 先清除数据
      this.list2 = []
      this.list3 = []
      this.cForm.category2Id = ''
      this.cForm.category3Id = ''
     ·····
     // 根据一级id再获取二级数据
    },
    
// 二级分类select事件回调(当二级分类的option发生变化时去获取相应的三级分类的数据)
    async handler2() {
      // 先清除数据
      this.list3 = []
      this.cForm.category3Id = ''
      ·····
      // 根据二级id再获取三级数据
    },
```

#### 2.父组件动态获取三级分类id（自定义事件）

```js
// 父组件 attr.vue
<el-card style="margin: 20px auto">
      <CategorySelect @getCategoryId="getCategoryId" />
</el-card>
    
// 自定义事件的回调
    getCategoryId({ categoryId, level }) {
      // 区分三级分类相应的id,并在父组件内存储
      if (level === 1) {
        this.category1Id = categoryId
        this.category2Id = ''
        this.category3Id = ''
      } else if (level === 2) {
        this.category2Id = categoryId
        this.category3Id = ''
      } else {
        // 代表三级分类的id有了
        this.category3Id = categoryId
        // 发请求获取平台属性数据
        this.getAttrList()
      }
    },   
    
    
// 子组件 categorySelect
// 每一级select的options发生变化时调用自定义事件，并将对应的级别的分类id和级别传递给父组件，以下为完成功能的实现
async handler1() {
     // 1.清除数据
      this.list2 = []
      this.list3 = []
      this.cForm.category2Id = ''
      this.cForm.category3Id = ''
      // 2.解构出一级分类的id同时将id传递父组件
      const { category1Id } = this.cForm
      this.$emit('getCategoryId', { categoryId: category1Id, level: 1 })
      // 3.通过一级分类id 获取二级分类的数据
      const result = await this.$API.attr.reqCategory2List(category1Id)
      if (result.code === 200) {
        this.list2 = result.data
      }
   }
   
async handler2() {
     // 1.清除数据
      this.list3 = []
      this.cForm.category3Id = ''
      // 2.解构出二级分类的id回传给父组件
      const { category2Id } = this.cForm
      this.$emit('getCategoryId', { categoryId: category2Id, level: 2 })
      // 3.通过二级分类id 获取三级分类的数据
      const result = await this.$API.attr.reqCategory3List(category2Id)
      if (result.code === 200) {
        this.list3 = result.data
      }
   }
   
async handler3() {
      // 解构出三级分类的id
      const { category3Id } = this.cForm
      // 通过自定义事件，以对象的形式将数据传递给父组件，加level是为了区分是哪一级的id
      this.$emit('getCategoryId', { categoryId: category3Id, level: 3 })
      // 三级分类id全都有了之后，父组件会直接发请求
   }
```

#### 3.获取平台属性数据并展示

（1）写获取平台属性的接口

举例：    属性：颜色   属性值：黑色 白色 红色

```js
// 获取平台属性接口---需要带3级分类id去请求的
//  GET /admin/product/attrInfoList/{category1Id}/{category2Id}/{category3Id}
export const reqAttrList = (category1Id, category2Id, category3Id) => request({
  url: `/admin/product/attrInfoList/${category1Id}/${category2Id}/${category3Id}`,
  method: 'get'
})
```

（2）当三级分类选定后获取对应的平台属性展示在列表中（三级分类id有了就触发一次）

```js
 // 获取平台属性数据
    async getAttrList() {
      // 3个id是子组件传递给父组件，父组件保存在自身的，所以需要再解构出来
      const { category1Id, category2Id, category3Id } = this
       // 带一二三级分类的id去获取数据
      const result = await this.$API.attr.reqAttrList(
        category1Id,
        category2Id,
        category3Id
      )
      if (result.code === 200) {
        this.attrList = result.data
      }
```

（3）属性展示列表&&添加属性button静态页面

将获取到的attrList数据以table表格呈现出来，显示序号则`type='index' `，属性值列表和操作列需要使用特殊样式【特殊样式就是除了文字之外的其他样式，按钮，气泡，开关等等都算】，需借助作用域插槽(可以接收`当前点击的元素形参row`)来实现

```js
 <el-card>
      <el-button type="primary" icon="el-icon-plus">添加属性</el-button>
      <!-- 表格：展示平台属性 -->
      <el-table :data="attrList" border style="margin: 10px 0" height="250">
        <el-table-column type="index" align="center" label="序号" width="80" />
        <el-table-column label="属性名称" width="150" prop="attrName" />
        <el-table-column label="属性值列表">
          <!-- 子组件的样式由父组件决定，使用作用域插槽,可以接收row,再从里面解构想要的属性值 -->
          <template slot-scope="{ row, $index }">
            <el-tag
              v-for="(attrValue, index) in row.attrValueList"
              :key="attrValue.id"
              type="success"
              style="margin: 0px 10px"
              >{{ attrValue.valueName }}</el-tag
            >
          </template>
        </el-table-column>
        <el-table-column label="操作" width="150">
          <template slot-scope="{ row, $index }">
            <el-button type="warning" icon="el-icon-edit" size="mini" />
            <el-button type="danger" icon="el-icon-delete" size="mini" />
          </template>
        </el-table-column>
      </el-table>
    </el-card>
```

#### 4.【添加属性】按钮的回调

添加按钮---category3Id不为空的时候才能使用，空的时候禁用   :disabled="!category3Id"

点击【添加/修改属性】之后，表格需要隐藏 isShowTable = false" 同时处理其他逻辑

```js
 <!-- 属性展示列表&&添加属性button -->
      <div v-show="isShowTable">
        <el-button
          type="primary"
          icon="el-icon-plus"
          :disabled="!category3Id"
          @click="addAttr"
        >添加属性</el-button>
        <!-- 表格：展示平台属性
        只要在el-table元素中定义了height属性，即可实现固定表头的表格，而不需要额外的代码。-->
        <el-table :data="attrList" border style="margin: 10px 0" height="250">
         ······
        </el-table>
      </div>


// 添加属性按钮的回调
    addAttr() {
      // 切换table显示与隐藏
      this.isShowTable = false
      // 清除数据，解决取消后数据回显问题
      // 收集三级分类的id
      this.attrInfo = {
        attrName: '', // 属性名
        attrValueList: [],
        categoryId: this.category3Id, // 三级分类的id
        categoryLevel: 3, // 服务器需要区分是哪级分类
      }
    },
```

#### 5.添加 | 修改属性的静态结构

当点击了页面上的【+添加属性】按钮后，会将`isShowTable改为false`，此时将不再显示表格，而是显示form，里面可以添加属性名及其他属性值等

![image-20220719113812078](https://raw.githubusercontent.com/Grayoul/cloudimg/master/data202207191138223.png)

```js
<!-- 添加属性 | 修改属性的结构 -->
      <div v-show="!isShowTable">
         // form 
        <el-form :inline="true">
          <el-form-item label="属性名">
            <el-input placeholder="请输入属性名" />
          </el-form-item>
        </el-form>
		// button---对输入的属性名进行操作
        <el-button type="primary" icon="el-icon-plus">添加属性值</el-button>
        <el-button type="" @click="isShowTable = true">取消</el-button>
		// table--展示属性值
        <el-table border style="width: 100%; margin: 20px 0">
          <el-table-column  label="序号"  type="index"  align="center"  width="80"/>
          <el-table-column label="属性值名称" width="width" />
          <el-table-column label="操作" width="width" />
        </el-table>
		// button
        <el-button type="primary">保存</el-button>
        <el-button type="" @click="isShowTable = true">取消</el-button>
      </div>
```

#### 6.收集平台属性名  

注意：对象存储数据是无序的，所以不能直接在data中进行数据的再赋值【一般不直接操作data中的值】，需要在添加分类的时候再赋值

(1) data中存储

```js
 // 收集新增属性|修改属性使用的
      attrInfo: {
        attrName: '', // 属性名
        attrValueList: [
          // 属性值列表，得是数组
          // {
          //   attrId: 0, // 相应的属性名的id
          //   valueName: '',
          // },
        ],
        categoryId: 0, // 三级分类的id
        categoryLevel: 3, // 服务器需要区分是哪级分类
      },
```

（2）属性名收集---收集后属性值表格可以直接使用

```js
<el-form-item label="属性名">
		<el-input v-model="attrInfo.attrName" placeholder="请输入属性名" />
</el-form-item>
```

#### 7.收集平台属性值

已有的属性，数据是服务器返回过来的，已经有了相应的id，但我们通过修改属性来添加属性值时，属性值是没有id的，所以我们需要给新增的属性值一个id，那么什么时候给新增的属性值id呢?`当点击添加属性值往数组里push的时候,就应该给新增的属性值添加id【attrInfo的id赋值给attrId】，同时将valueName设置为空`，等输入文字后再通过 v-model进行收集即可

添加属性值按钮在没有输入属性名的时候禁用：  ` :disabled="!attrInfo.attrName"` 注意需要先输入属性名，才能添加属性名分类下的不同属性值

```js
<el-button type="primary" icon="el-icon-plus" :disabled="!attrInfo.attrName" @click="addAttrValue">添加属性值</el-button>

// 添加属性值按钮的回调
    addAttrValue() {
      // 向属性值的数组里面添加元素，带着id,name等用户输入的时候收集
      // attrId：是相应的属性的id,目前还没有id,先写undefined，如果新增是有id的
      // valueName ：相应属性值的名称
      this.attrInfo.attrValueList.push({
        attrId: this.attrInfo.id, // 对于修改某一个属性的时候，可以在已有属性值基础上新增（需要将已有的id带上啊）
        valueName: '',
      })
    },
        
<el-table-column label="属性值名称" width="width">
    <template slot-scope="{row,$index}">             
         <el-input v-if="row.flag" :ref="$index" v-model="row.valueName" placeholder="请输入属性值名称" size="mini" /></el-input>
     </template>
</el-table-column>
```

#### 8.【添加属性】数据回显问题

点击【取消】按钮后再点击【添加属性】按钮，之前输入的属性名和对应的属性值都会残留，可在添加属性按钮的回调中进行清除，同时可将三级分类id获取到，取消之后列表还能获取到之前的数据进行展示

```js
// 添加属性按钮的回调
    addAttr() {
      // 切换属性table显示与隐藏
      this.isShowTable = false
      // 清除数据，解决取消后数据回显问题
      // 收集三级分类的id
      this.attrInfo = {
        attrName: '', // 属性名
        attrValueList: [],
        categoryId: this.category3Id, // 三级分类的id
        categoryLevel: 3, // 服务器需要区分是哪级分类
      }
    },
```

#### 9.【修改属性】按钮的回调

由于数组结构当中存在对象里套数组，数组里面套对象，需要使用`深拷贝`解决此类问题

```js
<el-button
    type="warning"
    icon="el-icon-edit"
    size="mini"
    @click="updateAttr(row)"
  />
              
              
// 按需引入lodash中深拷贝
import cloneDeep from 'lodash/cloneDeep'

// 修改某一个属性的回调
    updateAttr(row) {
      // 将table隐藏
      this.isShowTable = false
      // 将选中的属性赋值给attrInfo
      // 由于数组结构当汇总存在对象里套数组，数组里面套对象，需要使用深拷贝解决此类问题
      // 借助 lodash中的深拷贝解决
      this.attrInfo = cloneDeep(row)
     ·····
    },
```

#### 10.编辑和查看模式说明***

无论是【添加属性】还是【修改属性】的静态结构中的属性值列表table中都有查看和编辑两种模式

> 查看模式：显示span，只能看
>
> 编辑模式：显示input，可以输入文字，失焦或回车都会切换查看模式

解决思路：

在data设置flag属性，通过true和false去修改，但是需要注意的时候，一个属性flag没没办法分开控制不同的组件的属性，**要么都是查看，要么都是编辑**，那把flag放在哪里呢？

解决思路是,让每一个属性值去控制自己当前是查看模式还是编辑模式，那flag就不能放在data中,放data中只有一个，还是分不开，可以每次push新属性值的时候都要再加上 `flag为true`，让新增的属性控制自己是查看模式还是编辑模式，和其他元素不冲突

```js
// 添加属性值按钮的回调
    addAttrValue() {
      // 向属性值的数组里面添加元素
      this.attrInfo.attrValueList.push({
        attrId: this.attrInfo.id, // 对于修改某一个属性的时候，可以在已有属性值基础上新增（需要将已有的id带上啊）
        valueName: '',
        // flag属性：给每一个属性值添加一个标记flag,用户切换查看模式与编辑模式，好处：每一个属性值可以控制自己的模式切换，互相之间不影响，当前flag属性是响应式数据（数据变化视图跟着变化）
          // 这里的数组attrInfo，attrValueList都是在data中声明的，在data中声明的都是响应式数据，数组是push进来的，vue是可以检测到这个方法的，所以flag也是响应式的
        flag: true,
      })
```

结构部分

```vue
<el-table-column label="属性值名称" width="width">
    <template slot-scope="{row,$index}">
      <!-- 编辑(input)与查看(span)模式切换 
              @blur="toLook(row)" 鼠标离开隐藏 input 显示span 即为查看模式
              @click="toEdit(row, $index)" 点击span显示 input 隐藏span 即为编辑模式
              @keyup.native.enter="toLook(row)" input按回车显示span 隐藏 input
              修饰符 enter只能用于DOM事件，加上 native来进行触发   
			 style="display: block" 为了span方便点击，转换为块元素，让点击范围大一些
	-->
      <el-input v-if="row.flag" v-model="row.valueName" placeholder="请输入属性值名称" size="mini" @blur="toLook(row)" @keyup.native.enter="toLook(row)" /></el-input>
      <span v-else style="display:block" @click="row.flag=true">{{ row.valueName }}</span>
    </template>
</el-table-column>
```

#### 11.失焦或回车切换为查看模式

需要注意的：如果用户不输入内容或为空串，则需要提示用户不能输入空串，可以使用 trim()方法对输入的内容进行处理

关于trim()    Trim是String型数据的一个方法，作用是去掉字符串开头和结尾的空格，比如说字符串a="____a__"，其中_表示一个空格，那么a.Trim() = "a"，字符串前后的空格都被清掉了。调用这个方法后，a的值是不变的，也就是说，虽然a.Trim() = "a"，但a="____a__"还是成立的。

```js
// 添加属性值输入框失去焦点或按下回车触发的事件---切换为查看模式，显示span
    toLook(row) {
      //情况1： 如果属性值为空不能作为新的属性值，需要给用户提示，让输入一个不为空的值
      if (row.valueName.trim() === '') {
        this.$message('请输入一个不为空的属性值')
        return
      }
      // 情况2：新增的属性值不能与已有的属性值重复
      const isRepeat = this.attrInfo.attrValueList.some((item) => {
        // row是最新添加的值，需要把已有的数组当中新增的这个属性值去掉，之和前面添加的比较
        // 判断的时候，不等于的话可以将其去除
        if (row !== item) {
          // 属性值相等返回
          return row.valueName === item.valueName
        }
      })
      if (isRepeat) {
        this.$message('属性值重复请重新输入')
        return
      }
      // row：形参是当前用户添加的最新的属性值
      // 切换为查看模式
      row.flag = false
    },
```

另外属性的属性值不应该有重复的，row是用户输入的最新的属性值就是最后添加的属性值，而所有的属性值在attrInfo里面的attrValueList里面，可以使用some遍历attrValueList数组，但应该把自身排除,不能拿自己的valueName和自己判断,不然永远都是重复的,再和剩下的数组中每一个属性值item进行比较【**some只要一个重复就为真，主要是用于测试数组中是不是至少有一个元素通过了被提供的函数测试。**】

#### 11.【修改属性】的编辑查看模式

点击修改按钮进入的界面无法进行编辑模式和查看模式的切换，因为在数据中属性的数值身上没有flag字段，因此没办法利用flag来实现查看模式与编辑模式的切换，可以手动添加flag属性,但是会发现视图不会跟着变化(因为flag不是响应式数据)，因为Vue无法检测到普通的新增则没办法实现视图的更新

**总结：手动添加的属性必须为响应式数据，否则Vue无法检测到则没办法实现视图的更新**

```js
// 场景一的数据是服务器获取来的
 // 获取平台属性数据
    async getAttrList() {
      const { category1Id, category2Id, category3Id } = this
      // 带一二三级分类的id去获取数据
      const result = await this.$API.attr.reqAttrList(
        category1Id,
        category2Id,
        category3Id
      )
      if (result.code === 200) {
        this.attrList = result.data
      }
    },


// 修改某一个属性的回调---此时的数据是从服务器获取的，没有flag属性
    updateAttr(row) {
      ·······
      // 在修改某一个属性的时候，将相应的属性值元素添加上flag这个标记，便于切换编辑和查看模式
      this.attrInfo.attrValueList.forEach((item) => {
        // 以下代码可以添加flag属性，但视图不会跟着变化，因为数据不是响应式的
        // item.flag = false
        // 必须用于向响应式对象上添加新 property，因为Vue无法探测到普通的新增 property
        // 需要使用$set  格式： 给谁添加  什么属性  属性值
        this.$set(item, 'flag', false)
      })
    },
```

#### 12.场景一删除属性操作

```js
// 结构
<!-- 删除气泡 -->
  <el-popconfirm
    :title="`确定删除${row.attrName}吗？`"
    @onConfirm="deleteAttr(row, $index)"
  >
    <el-button
      slot="reference"  type="danger"  icon="el-icon-delete"
      size="mini"  style="margin-left: 15px"   @click="isShow = true"/>
  </el-popconfirm>


// 行为
async deleteAttr(row, index) {
      // 删除指定数据
      this.attrList.splice(index, 1)
      try {
        // 发请求删除数据
        const result = await this.$API.attr.reqDeleteAttr(row.id)
        // 成功关闭弹框并提示
        if (result.code === 200) {
          this.isShow = false
          this.$message({
            type: 'success',
            message: '删除成功',
          })
        }
      } catch (error) {
        console.log('删除失败')
      }
    },
```

#### 13.场景二文本框自动聚焦

修改自动聚焦：给span写 toEdit(row)  方法，给input打`ref = $index` ,通过序号去区分不同的input，但span和input来回切换是需要时间的，可使用 `$nextTick `来控制

添加自动聚焦：对添加属性值的回调进行优化，加入新增的文本框自动聚焦的设置

```js
        
// 修改：点击span的回调，切换为编辑模式
    toEdit(row, $index) {
      row.flag = true
      // 获取input节点，实现自动聚焦
      // console.log(this.$refs[$index])   ----undefined
      // 注意：点击span的时候，切换为input编辑模式，是使用v-if和v-else实现的，会导致页面重绘和重排，对于浏览器而言这些都需要时间
      // 所以点击span的时候，不可能立马获取到input,因而出现了 undefined报错
      // 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
      this.$nextTick(() => {
        // 让相应的input自动聚焦
        this.$refs[$index].focus()
      })
    },

// 场景二：添加属性值按钮的回调
    addAttrValue() {
      // 向属性值的数组里面添加元素:id有就显示，没有写undefined
      this.attrInfo.attrValueList.push({
        attrId: this.attrInfo.id, // 对于修改某一个属性的时候，可以在已有属性值基础上新增（需要将已有的id带上啊）
        valueName: '',
        // flag属性：给每一个属性值添加一个标记flag,用户切换查看模式与编辑模式，好处：每一个属性值可以控制自己的模式切换，互相之间不影响，当前flag属性是响应式数据（数据变化视图跟着变化）
        flag: true,
      })
        +++
      // 新增的文本框自动聚焦，数组的最后一项：长度-1即为index
      this.$nextTick(() => {
        this.$refs[this.attrInfo.attrValueList.length - 1].focus()
      })
    },
        

```

#### 14.场景二删除属性值操作

点击后弹窗信息pop 气泡确认框，然后删除`（记住外层一定要加插槽，不然气泡确认框弹不出来）`

```js
 <!-- 删除按钮 -->
  <el-table-column label="操作" width="width" prop="prop">
    <template slot-scope="{row,$index}">
      <!-- pop 气泡确认框 -->
      <el-popconfirm
        :title="`确定删除${row.valueName}吗？`"
        @onConfirm="deleteAttrValue($index)"
      >
        <el-button slot="reference" type="danger" icon="el-icon-delete" size="mini" />
      </el-popconfirm>
    </template>
  </el-table-column>
```

```js
 // 气泡确定框的确定按钮回调
    // 项目中element版本 2.13 ，确定事件需要写成 onConfirm  新版本写成 confirm 注意区分
    deleteAttrValue(index) {
      // 当前删除属性值的操作是不需要发请求的
      this.attrInfo.attrValueList.splice(index, 1)
    },
```

#### 15.场景二保存属性值的操作

（1）结构

```js
<el-button type="primary" @click="addOrUpdateAttr">保存</el-button>
```

（2）接口

```js
// 添加属性与属性值接口
//   POST /admin/product/saveAttrInfo
export const reqAddOrUpdateAttr = (data) => request({
  url: `/admin/product/saveAttrInfo`,
  data,
  method: 'post'
})
```

（3）行为：这里需要先整理参数， 1.flag不需要带给服务器，需要删除  2.用户添加很多属性值且为空的属性值也不需要提交给服务器，通过筛选后再去给服务器发请求，提示保存成功，返回展示列表并重新获取数据

```js
// 保存按钮：添加属性或修改属性后保存的回调
    async addOrUpdateAttr() {
      // 整理参数
      // 1.flag不需要带给服务器
      // 2.用户添加很多属性值且为空的属性值也不需要提交给服务器
      this.attrInfo.attrValueList = this.attrInfo.attrValueList.filter(
        (item) => {
          // 过滤掉属性值为空的
          if (item.valueName != '') {
            //  删除掉flag属性
            delete item.flag
            return true
          }
        }
      )
      try {
        // 1、发请求保存数据
        await this.$API.attr.reqAddOrUpdateAttr(this.attrInfo)
        // 2、保存成功弹框
        this.$message({ type: 'success', message: '保存成功' })
        // 3、展示平台属性列表，切换为场景一
        this.isShowTable = true
        // 4、保存成功之后需要再次获取平台属性进行展示
        this.getAttrList()
      } catch (error) {
        console.log('保存失败')
      }
    },
```

#### 16.细节优化

当点击【添加属性】按钮后，三级联动下拉框禁用，需要父组件将属性值通过props传递给子组件，子组件再去使用，实现联动效果

```js
// 父组件内
<CategorySelect :show="!isShowTable" @getCategoryId="getCategoryId" />

// CategorySelect组件内，各级下拉框禁用设置
<!-- 给一级分类下拉框绑定数据和事件 -->
<el-select
      v-model="cForm.category1Id"
      placeholder="请选择"
      :disabled="show"
      @change="handler1"
    >
```

当属性值数组长度小于1的时候，保存按钮禁用，只有输入数据后才能使用

```js
 <!-- 如果属性值为空则【保存】按钮禁用 -->
<el-button type="primary" :disabled="attrInfo.attrValueList.length<1" @click="addOrUpdateAttr">保存</el-button>
```

## 6、SPU管理模块

#### 1.业务介绍

结构和平台属性管理模块类似，通过三级联动+table实现属性的查看与新增等业务

SPU类似于 People类   而SKU则是类的实例  小红  小明等，类似于类和实例的关系

#### 2.静态搭建

结构说明：由2个card组成，中间有间距（el-card style="margin: 20px auto"）

（1）第一个card  引入三级联动全局组件 + 自定义事件 可以把子组件相应的id传递给父组件

自定义事件参数： categoryId ：获取到一三三级分类的id  level：区分是哪级id

```js
<el-card style="margin: 20px auto">
      <!-- 三级联动组件 -->
      <CategorySelect :show="!show" @getCategoryId="getCategoryId" />
</el-card>

// 三级联动的自定义事件，可以把子组件相应的id传递给父组件
    // 解构出categoryId level
    getCategoryId({ categoryId, level }) {
      // 存储各级分类的id ，通过level区分
      if (level === 1) {
        this.category1Id = categoryId
        // 清除其他分级的id
        this.category2Id = ''
        this.category3Id = ''
      } else if (level === 2) {
        this.category2Id = categoryId
        // 清除三级id
        this.category3Id = ''
      } else {
        this.category3Id = categoryId
      }
    },
```

（2）第二个card 里面会有3部分切换，先写spu展示列表

展示列表的样式 ： 添加SPU按钮+table表格（序号，名称，描述，操作里有4个button）实现

```js
<el-card>
      <!--底部这里之后会有3部分切换-->
      <div>
        <!-- 展示SPU列表的结构 -->
        // button 按钮
        <el-button type="primary" icon="el-button-plus">添加SPU</el-button>
        // table表格
        <el-table border style="width: 100%; margin: 10px auto" :data="records">
          <el-table-column  label="序号"  align="center"  type="index"  width="80"/>
          <el-table-column label="SPU名称" prop="spuName" />
          <el-table-column label="SPU描述" prop="description" />
          <el-table-column label="操作">
            <!-- 使用插槽呈现样式，放4个按钮 -->
            <template slot-scope="{ row, $index }">
              <!-- 这里按钮将来用 hintButton替换,有hover提示功能 -->
              <el-Button  type="success"  icon="el-icon-plus"  size="mini" title="添加sku"/>
              <el-Button  type="warning"  icon="el-icon-edit"  size="mini" title="修改spu"/>
              <el-Button type="info" icon="el-icon-info" size="mini" title="查看当前spu的全部sku列表"/>
              <el-Button type="danger" icon="el-icon-delete" size="mini" title="删除spu"/>
            </template>
          </el-table-column>
        </el-table>
		// 分页器
        <el-pagination
          style="text-align: center"
          :total="total"
          :current-page="page"
          :page-size="3"
          :page-sizes="[3, 5, 10]"
          layout="prev,pager,next,jumper,->,sizes,total"
        />
      </div>
    </el-card>
```

#### 3.获取spu数据

什么时候获取spu数据？当三级分类id获取的时候，发请求获取spu数据

（1）获取SPU列表数据接口

```js
// 获取SPU列表数据的接口
//  GET /admin/product/{page}/{limit}   参数：三级分类id  当前页码page   每页记录数limit
export const reqSpuList = (page, limit, category3Id) => request({
  url: `/admin/product/${page}/${limit}`,
  method: 'get',
  params: {
    // KV一致省略V
    category3Id
  }
})
```

（2）发请求的函数

```js
// 获取SPU列表数据的方法 | 分页器的页码变化时候的回调
    async getSpuList(pages = 1) {
      // 给默认参数，如果有就用传入的，没有就用默认参数
      this.page = pages  // data中有
      const { page, limit, category3Id } = this
      // 参数：三级分类id category3Id  当前页码page   每页记录数limit
      const result = await this.$API.spu.reqSpuList(page, limit, category3Id)
      if (result.code === 200) {
        this.records = result.data.records
        this.total = result.data.total
      }
    },
```

（3）当三级分类id有了后调用——在getCategoryId里调用

```js
// 解构出categoryId level
    getCategoryId({ categoryId, level }) {
      // 存储各级分类的id ，通过level区分
      if (level === 1) {
       ···
      } else if (level === 2) {
        ···
      } else {
        this.category3Id = categoryId  // data中有
        // 三级id有了之后获取SPU列表数据进行展示
        this.getSpuList()
      }
    },
```

（4）table展示数据

```js
<el-table border style="width: 100%; margin: 10px auto" :data="records">
          <el-table-column  label="序号"  type="index"  width="80"/>
          <el-table-column label="SPU名称" prop="spuName" />
          <el-table-column label="SPU描述" prop="description" />
          <el-table-column label="操作">
            <!-- 使用插槽呈现样式 -->
            <template slot-scope="{ row, $index }">
              <!-- 这里按钮将来用 hintButton替换,有hover提示功能 --> 
            </template>
          </el-table-column>
</el-table>
```

#### 4.动态展示SPU列表

当分页器的当前页和每页展示条数变化时，再去获取最新的spu列表进行展示

（1）设置分页器回调

```js
<el-pagination
          ·····
          @current-change="getSpuList"
          @size-change="handleSizeChange"
        />
```

（2）页码变化的回调：借助获取方法实现，加入参数当前页码，如果初始化时当前页码默认是1，更改分页器页码时，则用最新的页码去获取数据

```js
// 获取SPU列表数据的方法 | 分页器的页码变化时候的回调
    async getSpuList(pages = 1) {
      // 给默认参数，如果有就用传入的，没有就用默认参数
      this.page = pages   // data中有
      const { page, limit, category3Id } = this
      // 参数：三级分类id category3Id  当前页码page   每页记录数limit
      const result = await this.$API.spu.reqSpuList(page, limit, category3Id)
      if (result.code === 200) {
        this.records = result.data.records
        this.total = result.data.total
      }
    },
```

（3）每页展示条数变化的回调

```js
// 分页器某一页展示数据条数变化时的回调
    handleSizeChange(limit) {
      // 修改参数
      this.limit = limit  // data中有
      // 再次发请求
      this.getSpuList()
    },
```

#### 5.封装带hover提示的button**

（1）HintButton结构

```js
<template>
  <!-- 借助a链接的hover功能 -->
  <a :title="title" style="margin: auto 10px">
    <!-- 使用 $attrs接收props属性，如果通过props接收过的，则不再此展示  $listeners接收自定义事件  -->
    <!-- 记住 v-bind 和 v-on 不可简写 -->
    <el-button v-bind="$attrs" v-on="$listeners" />
  </a>
</template>

<script>
export default {
  name: 'HintButton',
  props: ['title'],
}
</script>
```

（2）main.js中注册为全局组件

```js
// 引入全局组件
import CategorySelect from '@/components/CategorySelect'
import HintButton from '@/components/HintButton'

// 注册全局组件
Vue.component(CategorySelect.name, CategorySelect)
Vue.component(HintButton.name, HintButton)
```

（3）组件内使用，动态传入的title即为hover提示的文本，其他则通过props传递给子组件

```js
 <HintButton
    type="success"
    icon="el-icon-plus"
    size="mini"
    title="添加sku"
  />
```

#### 6.Spu管理内容的切换

（1）内容切换分为3类场景，分别为：

- 场景一：展示spu列表结构---已完成
- 场景二：添加或修改spu结构---两者是一样的
- 场景三：展示添加sku的结构

（2）如何进行3类内容的场景切换？

添加一个标记 scene，通过值变化显示不同的组件

```js
data(){
    return {
         // 底部card切换不同展示内容的标记  0 展示spu列表  1 添加spu  2 查看sku
          scene: 0,
    }
}
```

（3）拆分组件并使用

组件使用流程：引入---注册----使用

```js
import skuForm from './skuForm'
import spuForm from './spuForm'

export default {
  name: 'Spu',
  components: {
    skuForm,
    spuForm,
  },
  
 <div v-show="scene === 0"></div>
 <spuForm v-show="scene === 1" />
 <skuForm v-show="scene === 2" />
```

#### 7.spuForm静态

（1）category3Id为空的时候，【添加spu】按钮不可用的实现

```js
 <el-button  :disabled="!category3Id"  @click="addSpu">添加SPU</el-button >
```

（2）添加和修改的时候将 scene改为1，即可显示结构

```js
this.scene = 1
```

（3）完成静态搭建

form表单内嵌不同的item，特别注意：spu描述使用文本域，spu图片使用照片墙，销售属性内嵌下拉框+table多个元素，最后一行按钮单独为一个item。**注意：照片墙上传图片不显示，因为存在跨域问题，后面更换提交图片的地址就能解决了**

```js
<el-form label-width="80px">
      <el-form-item label="SPU名称">
        <el-input placeholder="SPU名称" />
      </el-form-item>
      <el-form-item label="品牌">
        <el-select placeholder="请选择品牌" value="">
          <el-option label="label" value="value" />
        </el-select>
      </el-form-item>
      <el-form-item label="SPU描述">
        <el-input type="textarea" placeholder="请输入SPU描述" rows="4" />
      </el-form-item>
      <el-form-item label="SPU图片">
        <!-- 照片墙组件 -->
        <el-upload
          action="https://jsonplaceholder.typicode.com/posts/"
          list-type="picture-card"
          :on-preview="handlePictureCardPreview"
          :on-remove="handleRemove"
        >
          <i class="el-icon-plus" />
        </el-upload>
        <el-dialog :visible.sync="dialogVisible">
          <img width="100%" :src="dialogImageUrl" alt="" />
        </el-dialog>
      </el-form-item>
      <el-form-item label="销售属性">
        <el-select placeholder="还有3未选择" value="">
          <el-option label="label" value="value" />
        </el-select>
        <el-button type="primary" icon="el-icon-plus" style="margin-left: 10px"
          >添加销售属性</el-button
        >
        <el-table border style="width: 100%; margin-top: 10px">
          <el-table-column label="序号" prop="prop" type="index" width="80" align="center"/>
          <el-table-column label="属性名" prop="prop" />
          <el-table-column label="属性值名称列表" prop="prop" />
          <el-table-column label="操作" prop="prop" />
        </el-table>
      </el-form-item>
      <el-form-item>
        <el-button type="primary">保存</el-button>
        <el-button type="">取消</el-button>
      </el-form-item>
    </el-form>
```

#### 8.spuForm业务

（1）需要发4次请求

- 获取某一个spu的信息，方便展示当前spu的信息
- 获取品牌属性，方便品牌下拉框使用   
- 获取当前spu的图片列表   
- 获取所有销售属性（一共3个），方便销售属性下拉框使用

（2）取消之后通知父组件切换显示场景，scene改成0，回到展示列表页---自定义事件

```js
 // spuForm组件
 <el-button @click="$emit('changeScene', 0)">取消</el-button>
 
 // SPU组件
 <spuForm v-show="scene === 1" ref="spu" @changeScene="changeScene" />
```

（3）spuForm在哪里发4个请求

在mounted中书写不行，上线的项目是每一次显示spuForm子组件的时候都会发4个请求，v-show只能控制子组件显示与隐藏，导致mounted只能执行一次，解决方法：**父组件内获取子组件，获取子组件的方法**

```js
 <spuForm v-show="scene === 1" ref="spu" @changeScene="changeScene" />
 
  // 修改某一个spu
    updateSpu(row) {
      this.scene = 1
      // 获取子组件spuForm子组件
      // 在父组件当中可以通过$ref获取子组件,子组件身上的方法等
      this.$refs.spu.initSpuData(row)
    },
    
 // 初始化spuForm数据
    initSpuData(spu) {
      console.log('初始化', spu)
      // 具体获取方式请见下一节
    },
```

#### 9.获取spuForm数据--4个请求

已经完成的项目每一次显示SpuForm子组件的时候，都会发四个请求，分别为 spus，品牌，spu图片，平台属性，所以我们需要做的是先写接口，然后研究在哪里触发，才能实现每次显示子组件都发4个请求

（1）书写4个接口

```js
// 获取SPU信息
// GET /admin/product/getSpuById/{spuId}
export const reqSpu = (spuId) => request({
  url: `/admin/product/getSpuById/${spuId}`,
  method: 'get'
})

// 获取品牌的信息
//  GET /admin/product/baseTrademark/getTrademarkList
export const reqTradeMarkList = () => request({
  url: '/admin/product/baseTrademark/getTrademarkList',
  method: 'get'
})

// 获取spu图片的接口
// GET /admin/product/spuImageList/{spuId}
export const reqSpuImageList = (spuId) => request({
  url: `/admin/product/spuImageList/${spuId}`,
  method: 'get'
})

// 获取平台属性的接口--一共有3个，不会多于3个
// GET /admin/product/baseSaleAttrList
export const reqBaseSaleAttrLisr = () => request({
  url: '/admin/product/baseSaleAttrList',
  method: 'get'
})
```

（2）发请求

SpuForm子组件在哪里发请求地方？

不能放在子组件的mounted里面，因为v-show只是控制SpuForm子组件显示与隐藏，这个子组件并没有卸载（只是显示或者隐藏），导致mounted只能执行一次，不能每次显示子组件都触发。

可以每次父组件点击【修改spu】按钮的时候,通知它的子组件发请求，即可一下发4个请求获取到相应的数据

那么我们需要思考,在父组件当中如何拿到子组件,再让子组件去调用自己的方法，实现每次都一下发4个请求的功能

其实可以这样解决,我们现在是在父组件,在父组件当中是可以获取到子组件的,那么你就可以使用子组件的属性和方法,每次点击修改spu按钮的时候让子组件发请求就可以了

在父组件中:

在views/product/Spu/index.vue中: 

```js
 <!-- 添加或修改spu结构 打ref标识，方便获取到子组件-->
<spuForm v-show="scene === 1" ref="spu" @changeScene="changeScene" />
```

点击【修改spu】回调，会触发自定义事件，这样就能获取子组件身上的方法了

```js
 // 修改某一个spu
    updateSpu(row) {
      this.scene = 1
      // 获取子组件spuForm子组件
      // 在父组件当中可以通过$ref获取子组件,那就可以使用子组件身上的方法
      this.$refs.spu.initSpuData(row)
    },
```

在子组件中:

在views/product/Spu/SpuForm/index.vue中发4个请求获取数据

```js
// 初始化spuForm数据,接收父组件传递过来的row
    async initSpuData(spu) {
      // 获取spu数据
      const result = await this.$API.spu.reqSpu(spu.id)
      if (result.code === 200) {
        // 在修改spu的时候需要向服务器发请求，把服务器返回的数据，赋值给spu
        this.spu = result.data
      }
      // 获取品牌的信息
      const tradeMarkResult = await this.$API.spu.reqTradeMarkList()
      if (tradeMarkResult.code === 200) {
        this.tradeMarkList = tradeMarkResult.data
      }
      // 获取spu图片的信息
      const spuImageResult = await this.$API.spu.reqSpuImageList(spu.id)
      if (spuImageResult.code === 200) {
        this.spuImageList = spuImageResult.data
      }
      // 获取平台全部的销售属性
      const saleResult = await this.$API.spu.reqBaseSaleAttrLisr()
      if (saleResult.code === 200) {
          
        this.saleAttrList = saleResult.data
      }
    },
```

#### 10.spuForm数据展示与收集

当我们点击修改spu的时候,不仅仅只是考虑如何展示这个数据,我们还需要考虑一件事,就是把用户需要修改的数据也需要收集到,比如我们把小米10改成小米11,修改后我们点击保存,那么修改完成的数据点击保存的时候还需要提交给服务器。添加spu的时候是最后发请求，带参数给服务器，和修改spu的顺序不一样

（1）data中数据结构

```js
 // 存储spu信息属性,初始化的时候是一个空对象,在修改spu的时候会向服务器发请求，返回spu信息，在修改的时候可以利用服务器返回的这个对象收集最新的数据提交给服务器
// 但添加spu,并没有向服务器发请求，那数据收集到哪里？spu  收集数据的时候有哪些字段呢？
      spu: {
        category3Id: 0,
        description: '',
        spuName: '',
        tmId: 0,
        // spu图片
        spuImageList: [
          {
            id: 0,
            imgName: 'string',
            imgUrl: 'string',
            spuId: 0,
          },
        ],
        spuSaleAttrList: [
		·····
        ],
      },
```

（2）spu名称：收集   `v-model="spu.spuName"`

```js
<el-form-item label="SPU名称">
        <el-input v-model="spu.spuName" placeholder="SPU名称" />
</el-form-item>
```

（3）品牌：下拉框数据展示与收集   `v-model="spu.tmId"`

```js
 <el-select v-model="spu.tmId" placeholder="请选择品牌">
      <el-option
        v-for="(tm, index) in tradeMarkList"
        :key="tm.id"
        :label="tm.tmName"
        :value="tm.id"
      />
</el-select>
```

（4）spu描述：数据展示与收集    `v-model="spu.description"`

```js
 <el-input
          v-model="spu.description"
          type="textarea"
          placeholder="请输入SPU描述"
          rows="4"
        />
```

（5）spu图片：目前只做了数据展示，未做收集。此处图片需要展示多张,可以elementui里面的一个属性`file-list="fileList"`来实现

```js
 <!-- 照片墙组件 action图片上传的地址  list-type：文件列表的类型
        on-preview:点击文件列表中已上传的文件时的钩子
        on-remove:文件列表移除文件时的钩子 -->
        <el-upload
          action="/dev-api/admin/product/fileUpload"
          list-type="picture-card"
          :on-preview="handlePictureCardPreview"
          :on-remove="handleRemove"
          :file-list="spuImageList"
        >
```

注意ile-list的数据中需要有name和url的数据,而服务器返回的数据中是imgName和imgUrl,需要存储数据前做格式处理

```js
// 获取spu图片的信息
      const spuImageResult = await this.$API.spu.reqSpuImageList(spu.id)
      if (spuImageResult.code === 200) {
        // 由于照片前显示图片的数据需要数组，数组里是对象，有name和url字段
        // 需要把服务器返回的数据进行修改
        const arrtList = spuImageResult.data
        arrtList.forEach((item) => {
          item.name = item.imgName
          item.url = item.imgUrl
        })
        // 把整理好的数据赋值给spuImageList,动态展示需要加 ：
        this.spuImageList = arrtList
      }
```

#### 11.spuForm的销售属性展示与收集

整个项目当中销售属性一共三个，颜色，尺码，版本，需要展示自身拥有的销售属性，同时自己没有但全部属性里有的还可以再进行添加

（1）展示自身拥有的销售属性

```js
<!-- 展示的是当前spu自身的销售属性spuSaleAttrList,名称即为saleAttrName -->
<el-table  border style="width: 100%; margin-top: 10px" :data="spu.spuSaleAttrList">
          ·····
      <el-table-column label="属性名" prop="saleAttrName" width="80" />
      <el-table-column label="属性值名称列表" prop="prop" width="width">
        <template slot-scope="{ row, $index }">
          <!--  @close="handleClose(tag)" -->
          <el-tag
            v-for="tag in row.spuSaleAttrValueList"
            :key="tag.id"   closable  :disable-transitions="false">
                {{ tag.saleAttrValueName }}
          </el-tag>
          <!-- 底下的结构可以当作编辑和查看模式的切换 -->
          <el-input
            v-if="row.inputVisible"
            ref="saveTagInput"
            v-model="row.inputValue"
            class="input-new-tag"
            size="small"/>
          <el-button v-else class="button-new-tag" size="small">+ 添加</el-button>
        </template>
      </el-table-column>
      <el-table-column label="操作" prop="prop" width="80">
       ···
      </el-table-column>
</el-table>
```

（2）销售属性下拉框动态展示

需要从平台全部的销售属性中将自身拥有的属性过滤掉，数组长度即为未选择的数量，数组的内容即为option遍历的数组，将其展示出来，记住这里一定要写动态的数据，属性前加 ：

平台全部的销售属性----saleAttrList

当前spu拥有的自己的销售属性---spu.spuSaleAttrList

```js
 <el-select
          v-model="attrId"
          :placeholder="`还有${unSelectSaleAttr.length}未选择`"
        >
          <el-option
            v-for="(unSelect, index) in unSelectSaleAttr"
            :key="unSelect.id"
            :label="unSelect.name"
            :value="unSelect.id"
          />
        </el-select>


 computed: {
    // 计算出还未选择的销售属性
    unSelectSaleAttr() {
      // 平台全部的销售属性----saleAttrList
      // 当前spu拥有的自己的销售属性---spu.spuSaleAttrList
      // 数组的过滤，会返回一个新的数组,从全部销售属性里将已有销售属性中一样的过滤掉
      const result = this.saleAttrList.filter((item) => {
        // every 返回一个布尔值，真要，假不要
        return this.spu.spuSaleAttrList.every((item1) => {
          return item.name !== item1.saleAttrName
        })
      })
      return result
    },
  },
```

（3）添加销售属性按钮的禁用

当用户没有选择下拉框的销售属性时则禁用，选择了就可以使用了,attrId收集的是未选择的销售属性的id

```js
<el-button type="primary" icon="el-icon-plus" style="margin-left: 10px" :disabled="!attrId">
    添加销售属性
</el-button>
```

#### 12.spuForm照片墙数据的收集

目前只是对照片墙的数据进行了展示,并没有进行收集,当我们删除或者新增照片的时候,都需要传重新提交服务器,下一次进来的时候数据一定是会发生变化的

预览照片墙显示大图片的时候，需要收集数据吗？----不需要收集【因为数据已经有了】

照片墙在删除图片的时候，需要收集数据

```js
// 照片墙删除图片时会触发----:on-remove="handleRemove"
    handleRemove(file, fileList) {
      // file：代表删除的那张图片
      // fileList：代表删除后剩余的图片的数组
      // 收集照片墙图片的数据(需要再删除name url字段，这两个属性是照片墙显示需要的属性，但服务器并不需要)
      this.spuImageList = fileList
    },
```

照片墙在添加图片的时候，需要收集数据

```js
// 照片墙图片上传成功的回调---:on-success="handleSuccess"
    handleSuccess(response, file, fileList) {
      // 参数分别为：真实图片地址，上传成功的图，上传成功后所有图片
      console.log(fileList)
      // 收集图片的信息
      this.spuImageList = fileList
    },
```

#### 13.销售属性的添加操作

（1）收集哪些属性

- baseSaleAttrId

- saleAttrName

- spuSaleAttrValueList


（2）在什么时候收集数据--点击添加销售属性按钮的时候收集，这样写 `${unSelect.id}:${unSelect.name}` id和name一块收集起来

```js
<el-select
          v-model="attrIdAndAttrName"
          :placeholder="`还有${unSelectSaleAttr.length}未选择`"
        >
          <el-option
            v-for="(unSelect, index) in unSelectSaleAttr"
            :key="unSelect.id"
            :label="unSelect.name"
            :value="`${unSelect.id}:${unSelect.name}`"
          />
        </el-select>
<el-button
          type="primary"
          icon="el-icon-plus"
          style="margin-left: 10px"
          :disabled="!attrIdAndAttrName"
          @click="addSaleAttr"
          >添加销售属性</el-button
        >                          
```

（3）收集到哪里？ --把数据收集到SPU属性身上，因为点击添加属性按钮不仅要收集数据还要展示数据,而展示数据是在table中,并且table展示数据用的是spu.spuSaleAttrList,所以收集数据就放这里面

```js
 // 添加新的销售属性
    addSaleAttr() {
      // 已经收集到需要添加的销售属性的信息
      // 把收集到的销售属性数据进行分割,整理成服务器需要的格式
      const [baseSaleAttrId, saleAttrName] = this.attrIdAndAttrName.split(':')
      // 向SPU对象的spuSaleAttrList中添加新的销售属性
      const newSaleAttr = {
        baseSaleAttrId,
        saleAttrName,
        spuSaleAttrValueList: [],
      }
      // 添加新的销售属性
      this.spu.spuSaleAttrList.push(newSaleAttr)
        // 清空数据框数据
      this.attrIdAndAttrName = ''
    },
```

#### 14.添加spu中销售属性值展示与收集

（1）点击添加按钮回调

需要将button变成input，做法就是向row销售属性的身上添加 `inputVisible` 属性控制button和input切换，`inputValue`用于收集新增的销售属性值

```js
<el-input  v-if="row.inputVisible"  ref="saveTagInput" v-model="row.inputValue"
      class="input-new-tag" size="small"  @blur="handleInputConfirm(row)"/>

<el-button  v-else  class="button-new-tag" size="small" @click="addSaleAttrValue(row)"
>+ 添加</el-button>

// 添加按钮的回调
    addSaleAttrValue(row) {
      // 点击销售属性值当中添加按钮的时候，需要将button变成input
      // 向row销售属性的身上添加一个，控制button和input切换($set添加响应式数据)
      // row.inputVisible = true
      this.$set(row, 'inputVisible', true)
      // 通过响应式数据 收集新增的销售属性值
      this.$set(row, 'inputValue', '')
    },
```

（2）input失去焦点回调

当我们失去焦点的时候,需要把新增的销售属性值放到spuSaleAttrValueList的数组里面,而且数据里面格式需要包含`baseSaleAttrId和saleAttrValueName`这两个属性才行

```js
// el-input失去焦点的回调
    handleInputConfirm(row) {
      // 解构出 baseSaleAttrId  inputValue
      const { baseSaleAttrId, inputValue } = row
      // 1.属性值不能为空
      if (inputValue.trim() === '') {
        this.$message('属性值不能为空')
        return
      }
      // 2.属性值不能重复
      const result = row.spuSaleAttrValueList.every(
        (item) => item.saleAttrValueName !== inputValue
      )
      if (!result) {
        // result为真代表不重复，假为重复需要返回
        this.$message('属性值不能重复')
        return
      }
      ===============用some需要改成相等，如果为真代表重复===============  
         const result = row.spuSaleAttrValueList.some(
        (item) => item.saleAttrValueName === inputValue
      )
      if (result) {
        // result为真代表重复需要返回
        this.$message('属性值不能重复')
        return
      }
      ============================================
        
      // 整理成服务器需要的格式
      const newSaleAttrValue = { baseSaleAttrId, saleAttrValueName: inputValue }
      // push到属性值列表中
      row.spuSaleAttrValueList.push(newSaleAttrValue)
      // 修改inputVisible = false，显示button
      row.inputVisible = false
    },
```

#### 15.删除销售属性和属性值

（1）删除属性值：tag后面的小叉号

```js
<!-- el-tag：展示已有的属性值列表的数据,index即为销售属性值的索引值，和$index是不同的 -->
              <el-tag
                v-for="tag in row.spuSaleAttrValueList"
                :key="tag.id"
                closable
                :disable-transitions="false"
                @close="row.spuSaleAttrValueList.splice(index, 1)"
              >
```

（2）删除销售属性：删除按钮

```js
 <el-button
                type="danger"
                icon="el-icon-delete"
                size="mini"
                @click="spu.spuSaleAttrList.splice($index, 1)"
              />
```

（3）三级联动的可操作性

```js
 <!-- 三级联动组件,场景不等于0就不能操作 -->
      <CategorySelect :show="scene !== 0" @getCategoryId="getCategoryId" />
```

#### 16.修改spu的保存操作

（1）先写接口，判断id是否有，决定是添加还是修改

```js
// 修改spu | 添加spu :携带给服务器参数大致一样，区分是有没有id
// 修改url /admin/product/updateSpuInfo   添加url /admin/product/saveSpuInfo   post请求
export const reqAddOrUpdateSpu = (spuInfo) => {
  // 携带的参数有id---修改spu
  if (spuInfo.id) {
    return request({
      url: '/admin/product/updateSpuInfo',
      method: 'post',
      data: spuInfo
    })
  } else {
    return request({
      url: '/admin/product/saveSpuInfo',
      method: 'post',
      data: spuInfo
    })
  }
}
```

（2）照片墙数据需要整理，服务器需要imageName和imageUrl字段【不需要name和url】，最后统一整理到spu身上

```js
// 保存按钮的回调
    async addOrUpdateSpu() {
      // 整理参数：需要整理照片墙的数据
      // 携带参数：对于图片，需要携带imgName和imgeUrl字段，但新增的图片是没有这两个属性的
      this.spu.spuImageList = this.spuImageList.map((item) => {
        return {
          imgName: item.name,
          // 新增加的图需要使用response中的data作为路径，之前就有的图使用url做路劲即可
          imgUrl: (item.response && item.response.data) || item.url,
        }
      })
      // 发请求
      const result = await this.$API.spu.reqAddOrUpdateSpu(this.spu)
      ····
    },
```

（3）请求成功，提示框提醒，切换场景到0

```js
 if (result.code === 200) {
        this.$message({ type: 'success', message: '保存成功' })
        // 通知父组件切换场景---展示列表
        this.$emit('changeScene', 0)
      }
```

（4）修改之后回到场景0后，父组件中还需要停留在当前那页，属于细节优化

```js
 // spuForm的自定义事件回调
    changeScene(scene) {
      // 切换场景
      this.scene = scene
      // 获取数据
      this.getSpuList(this.page)
    },
```

#### 17.添加spu的操作

点击添加SPU按钮的时候，需要发两个请求（1.获取品牌的数据、全部销售属性的数据），但三级分类id需要单独收集

（1）父组件通知子组件发请求

```js
// 添加SPU按钮的回调
    addSpu() {
      this.scene = 1
      // 通知子组件spuForm发请求--1.获取品牌的数据 2.全部销售属性的数据
      this.$refs.spu.addSpuData(this.category3Id)
    },
```

（2）子组件自定义事件内发请求

```js
 // 点击添加SPU按钮的发请求的回调
    async addSpuData(category3Id) {
      // 添加SPU的时候收集三级分类id
      this.spu.category3Id = category3Id
      // 获取品牌的信息
      const tradeMarkResult = await this.$API.spu.reqTradeMarkList()
      if (tradeMarkResult.code === 200) {
        this.tradeMarkList = tradeMarkResult.data
      }
      // 获取平台全部的销售属性
      const saleResult = await this.$API.spu.reqBaseSaleAttrLisr()
      if (saleResult.code === 200) {
        this.saleAttrList = saleResult.data
      }
    },
```

（3）添加spu的保存功能

还有一个问题，如果是添加，列表默认展示第一页，如果是修改，显示原来的那页即可，那应该如果做区分？在传递scene时，多传递一个flag属性，如果有id则为更新，留在当前页，没有则是新增，留到第一页

```js
// spuForm子组件的回调
// 保存按钮的回调
    async addOrUpdateSpu() {
    ·······
    +
    if (result.code === 200) {
        this.$message({ type: 'success', message: '保存成功' })
        // 通知父组件切换场景---展示列表，并传递flag
        this.$emit('changeScene', {
          scene: 0,
          flag: this.spu.id ? '修改' : '添加',
        })
      }
   }

// 父组件自定义事件接收
// spuForm的自定义事件回调
    changeScene({ scene, flag }) {
      // flag形参：为了区分保存按钮是添加还是修改
      // 切换场景
      this.scene = scene
      // 获取数据
      if (flag === '修改') {
        this.getSpuList(this.page)
      } else {
        this.getSpuList()
      }
    },
```

（4）取消和保存的时候切换场景同时将之前的数据清空的优化操作

```js
// 取消按钮的回调
    cancel() {
      // 通知父组件将场景切换为0
      this.$emit('changeScene', { scene: 0, flag: '' })
      // 清理数据
      // Object.assign合并对象，es6新增的，后面的数据赋值给前面的
      // 组件实例this._data，可以操作data中的响应式数据
      // this.$options 可以获取配置对象，配置对象的data函数执行，返回的响应式数据为空
      Object.assign(this._data, this.$options.data())
    },
```

```js
// 保存按钮的回调
    async addOrUpdateSpu() {
     ·····
     +
      // 清除数据
      Object.assign(this._data, this.$options.data())
    },
```

#### 18.删除spu的业务

会弹出pop让用户去确认是否删除

```js
<el-popconfirm
                title="这是一段内容确定删除吗？"
                @onConfirm="deleteSpu(row)"
              >
                <HintButton
                  slot="reference"
                  type="danger"
                  icon="el-icon-delete"
                  size="mini"
                  title="删除spu"
                />
              </el-popconfirm>
```

（2）删除的接口

```js
// 删除spu
// url :  /admin/product/deleteSpu/{spuId}  DELETE
export const reqDeleteSpu = (spuId) => request({
  url: `/admin/product/deleteSpu/${spuId}`,
  method: 'delete'
})
```

（3）删除按钮的回调

```js
// 删除按钮的回调
    async deleteSpu(row) {
      // 发删除请求
      const result = await this.$API.spu.reqDeleteSpu(row.id)
      if (result.code === 200) {
        this.$message({ type: 'success', message: '删除spu成功' })
        // 如果spu个数的数组长度大于1留在当前页，否则回到上一页
        this.getSpuList(this.records.length > 1 ? this.page : this.page - 1)
      }
    },
```

#### 18.添加sku模块请求

（1）父组件应该通知子组件发3个请求

```js
// 添加sku按钮的回到
    addSku(row) {
      // console.log(row)
      // 切换场景为2，展示skuForm子组件
      this.scene = 2
      // 父组件调用子组件的方法，让子组件发请求---3个请求
      // row即为当前点击的这行spu数据
      this.$refs.sku.getData(this.category1Id, this.category2Id, row)
    },
```

（2）书写3个请求的接口

```js
// 获取图片的接口
//  url：/admin/product/spuImageList/{spuId}  get
export const reqSpuImageList = (spuId) => request({
  url: `/admin/product/spuImageList/${spuId}`,
  method: 'get'
})

// 获取销售属性的数据
//  GET /admin/product/spuSaleAttrList/{spuId}
export const reqSpuSaleAttrList = (spuId) => request({
  url: `/admin/product/spuSaleAttrList/${spuId}`,
  method: 'get'
})

// 获取平台属性的数据
//  /admin/product/attrInfoList/{category1Id}/{category2Id}/{category3Id}   get
export const reqAttrInfoList = (category1Id, category2Id, category3Id) => request({
  url: `/admin/product/attrInfoList/${category1Id}/${category2Id}/${category3Id}`,
  method: 'get'
})
```

（3）子组件skuForm发请求

```js
 // 获取skuForm数据
    async getData(category1Id, category2Id, spu) {
      // 收集父组件给的spu的数据（就是传递过来的row）
      this.skuInfo.category3Id = spu.category3Id
      this.skuInfo.spuId = spu.id
      this.skuInfo.tmId = spu.tmId
      this.spu = spu

      // promise.all同时处理多个异步
      // 获取图片的数据
      const result = await this.$API.sku.reqSpuImageList(spu.id)
      if (result.code === 200) {
        this.spuImageList = result.data
      }
      // 获取销售属性的数据
      const result1 = await this.$API.sku.reqSpuSaleAttrList(spu.id)
      if (result1.code === 200) {
        this.spuSaleAttrList = result1.data
      }
      // 获取平台属性的数据
      const result2 = await this.$API.sku.reqAttrInfoList(
        category1Id,
        category2Id,
        spu.category3Id
      )
      if (result2.code === 200) {
        this.attrInfoList = result2.data
      }
    },
```

#### 19.添加sku功能的数据展示与收集

整体使用form实现，每一行是一个form-item，根据需求插入不同的组件，input,seleect等

（1）简单属性收集：价格type为number，规则描述type为"textarea

```js
 <!-- label-width：表单域标签的宽度，例如 '50px'。作为 Form 直接子元素的 form-item 会继承该值。 -->
    <el-form label-width="80px">
      <el-form-item label="SPU名称">{{ spu.spuName }}</el-form-item>
      <el-form-item label="SKU名称">
        <el-input v-model="skuInfo.skuName" placeholder="SKU名称" />
      </el-form-item>
      <!-- type="number"可以出现增加和减少的箭头，既可以手动输入也可以通过箭头进行数字修改，默认为0元 -->
      <el-form-item label="价格(元)">
        <el-input
          v-model="skuInfo.price"
          placeholder="价格(元)"
          type="number"
        />
      </el-form-item>
      <el-form-item label="重量(千克)">
        <el-input v-model="skuInfo.weight" placeholder="重量(千克)" />
      </el-form-item>
      <el-form-item label="规格描述">
        <el-input v-model="skuInfo.skuDesc" rows="4" type="textarea" />
      </el-form-item>
```

（2）平台属性

![Snipaste_2022-09-15_15-59-41](https://raw.githubusercontent.com/Grayoul/cloudimg/master/data202209151604622.jpg)

为什么将下拉框的数据收集到平台属性身上，这样平台属性有100个，就能收集到100个，一一对应的

```js
<!-- 平台属性部分，item内嵌form表单，再去嵌套需要的数据实现的 -->
      <el-form-item label="平台属性">
        <el-form :inline="true">
          <el-form-item
            v-for="(attr, index) in attrInfoList"
            :key="attr.id"
            :label="attr.attrName"
          >
            <el-select v-model="attr.arrtIdAndValueId" placeholder="请选择">
              <el-option
                v-for="(attrValue, index) in attr.attrValueList"
                :key="attrValue.id"
                :label="attrValue.valueName"
                :value="`${attr.id}:${attrValue.id}`"
              />
            </el-select>
          </el-form-item>
        </el-form>
      </el-form-item>
```

（3）销售属性

先遍历item，可以生成多个下拉框，再遍历options，生成下拉框的数据，另外将数据收集到select身上

```js
 <el-form-item label="销售属性">
        <el-form :inline="true">
          <el-form-item
            v-for="(saleAttr, index) in spuSaleAttrList"
            :key="saleAttr.id"
            :label="saleAttr.saleAttrName"
          >
            <el-select v-model="saleAttr.attrIdAndValue" placeholder="请选择">
              <el-option
                v-for="(saleAttrValue, index) in saleAttr.spuSaleAttrValueList"
                :key="saleAttrValue.id"
                :label="saleAttrValue.saleAttrValueName"
                :value="`${saleAttr.id}:${saleAttrValue.id}"
              />
            </el-select>
          </el-form-item>
        </el-form>
      </el-form-item>
```

#### 20.添加sku的图片列表

（1）收集选中的图片到 imageList

@selection-change :当选择项发生变化时会触发该事件

```js
 <el-table  border :data="spuImageList" @selection-change="handleSelectionChange" >
        
// table复选框按钮的事件--获取全部勾选的图片
   handleSelectionChange(params) {
      // params 即为选中的图片的信息
      // 获取到用户选中图片的信息数据，但需要注意，当前收集的数据中，缺少isDefault字段
      // 解决方式：在getData获取数据的时候就添加上sDefault字段
      this.imageList = params
    },
        
        
// 获取图片的数据
    getData(){      
     ·····
       +
      const result = await this.$API.spu.reqSpuImageList(spu.id)
      if (result.code === 200) {
        const list = result.data
        // 给每条数据加上isDefault字段
        list.forEach((item) => {
          item.isDefault = 0
        })
        this.spuImageList = list
      }
      +
    } 
```

（2）将图片设为默认会被收集到skuInfo中的skuDefaultImg中

```js
//  就是两个button的切换，通过手动添加的isDefault来控制，默认都是0，点击后变成1
<el-table-column label="操作">
            <template slot-scope="{ row, $index }">
              // 设置默认按钮
              <el-button
                v-if="row.isDefault === 0"
                type="primary"
                @click="changeDefault(row)"
                >设置默认</el-button
              >
              // 默认按钮
              <el-button v-else type="success" plain>默认</el-button>
            </template>
</el-table-column>



// 排他思想，进当前点击的变成绿色按钮
changeDefault(row) {
      // 图片列表的数据的isDefault都改成0
      this.spuImageList.forEach((item) => {
        item.isDefault = 0
      })
      // 将点击项的isDefault改为1
      row.isDefault = 1
      // 设置为默认图片
      this.skuInfo.skuDefaultImg = row.imgUrl
    },
```

（3）图片列表动态展示

```js
<el-form-item label="图片列表">
        <el-table
          border
          :data="spuImageList"
          @selection-change="handleSelectionChange"
        >
          <el-table-column type="selection" width="80" />
          <el-table-column label="图片">
            <template slot-scope="{ row, $index }">
              <img :src="row.imgUrl" style="width: 100px; height: 100px" />
            </template>
          </el-table-column>
          <el-table-column label="名称" prop="imgName" />
          <el-table-column label="操作">
            ······
          </el-table-column>
        </el-table>
      </el-form-item>
```

#### 21.添加sku的保存操作

（1）写添加sku接口

```js
// 添加sku
//  /admin/product/saveSkuInfo   post
export const reqAddSku = (skuInfo) => request({
  url: '/admin/product/saveSkuInfo',
  method: 'post',
  data: skuInfo
})
```

（2）保存sku的回调

```js
// 保存按钮的回调
    async savaSku() {
      // 收集数据提交给服务器
      // 整理平台属性数据,如果有arrtIdAndValueId代表当前平台属性用户选中了，将此属性分割后以对象的形式push进skuInfo.skuAttrValueList
      skuInfo.skuAttrValueList = attrInfoList.reduce((prev, item) => {
        if (item.arrtIdAndValueId) {
          const [attrId, valueId] = item.arrtIdAndValueId.split(':')
          prev.push({ attrId, valueId })
        }
        return prev
      }, [])

      // 整理销售属性
      skuInfo.skuSaleAttrValueList = spuSaleAttrList.reduce((prev, item) => {
        if (item.attrIdAndValue) {
          // 分割字符串
          const [saleAttrId, saleAttrValueId] = item.attrIdAndValue.split(':')
          // 以对象形式push进数组
          prev.push({ saleAttrId, saleAttrValueId })
        }
        return prev
      }, [])

      // 整理图片数据
      skuInfo.skuImageList = imageList.map((item) => {
        return {
          imgName: item.imgName,
          imgUrl: item.imgUrl,
          isDefault: item.isDefault,
          spuImgId: item.id,
        }
      })

      // 发请求：添加sku
      const result = await this.$API.spu.reqAddSku(skuInfo)
      if (result.code === 200) {
        this.$message({ type: 'success', message: '添加sku成功' })
        // 通知父组件切换场景为0
        this.$emit('changescene', 0)
        // 直接返回就行不需要再发请求，因为这里不需要查看
        Object.assign(this._data, this.$options.data())
      }
    },
```

#### 22.查看sku列表展示

（1）写请求接口

```js
// 获取SKU列表数据的接口
//  url /admin/product/findBySpuId/{spuId}  get
export const reqSkuList = (spuId) => request({
  url: `/admin/product/findBySpuId/${spuId}`,
  method: 'get'
})
```

（2）点击【查看sku】按钮时发请求获取数据

这里注意发请求携带参数，可以使用data中的 `this.spu.id`   也可以使用接收的参数 row.id

```js
// 查看全部sku按钮的回调
    async handler(row) {
      // 点击按钮显示对话框
      this.dialogTableVisible = true
      // 保存当前的spu
      this.spu = row
      // 获取sku列表的数据进行展示
      const result = await this.$API.spu.reqSkuList(row.id)
      if (result.code === 200) {
        this.skuList = result.data
        // 隐藏loading
        this.loading = false
      }
    },
```

（3）对话框动态展示获取到的数据

```js
<!-- 查看全部sku列表的对话框结构 -->
    <el-dialog
      :title="`${spu.spuName}的sku列表`"
      :visible.sync="dialogTableVisible"
      :before-close="close"
    >
      <el-table v-loading="loading" border :data="skuList">
        <el-table-column label="名称" width="width" prop="skuName" />
        <el-table-column label="价格" width="width" prop="price" />
        <el-table-column label="重量" width="width" prop="weight" />
        <el-table-column label="默认图片" width="width">
          <template slot-scope="{ row, $index }">
            <img :src="row.skuDefaultImg" style="width: 100px; height: 100px" />
          </template>
        </el-table-column>
      </el-table>
    </el-dialog>
```

（4）添加loading效果：问题：目前只能展示1次，快速切换sku查看会看到之前的数据，我们可以在关闭对话框的时候就将展示列表置空，从而解决问题

```js
<el-dialog
      :title="`${spu.spuName}的sku列表`"
      :visible.sync="dialogTableVisible"
      :before-close="close"
    >

// 关闭对话框的回调
    close(done) {
      // loading属性变为真
      this.loading = true
      // 置空，放置快速切换查看sku出现数据回显问题
      this.skuList = []
      // function(done)，done 用于关闭 Dialog
      done()
    },
```



## 7、SKU管理模块

#### 1.sku模块数据获取

通过table表格进行布局，挂载的时候就去请求sku列表数据，【默认图片】和【操作】列的结构需要使用作用域插槽进行展示

（1）获取sku列表数据

```js
// sku列表的接口
//  /admin/product/list/{page}/{limit}   get
export const reqSkuList = (page, limit) => request({
  url: `/admin/product/list/${page}/${limit}`,
  method: 'get'
})

// 页面挂载就去获取数据
mounted() {
    // 获取sku列表数据
    this.getSkuList()
  },
methods: {
// 发请求获取sku列表数据
    async getSkuList(pages = 1) {
      this.page = pages
      // 解构出参数
      const { page, limit } = this
      const result = await this.$API.sku.reqSkuList(page, limit)
      this.records = result.data.records
      this.total = result.data.total
    },
  }
```

#### 2.静态结构展示数据

```js
<!-- 表格 -->
    <el-table border style="width: 100%" :data="records" height="450">
      <el-table-column label="序号" type="index" width="80" align="center" />
      <el-table-column width="110" label="名称" align="center" prop="skuName" />
      <el-table-column label="描述" width="width" align="center" prop="skuDesc"/>
      <el-table-column label="默认图片" width="110" align="center">
        <template slot-scope="{ row, $index }">
          <img :src="row.skuDefaultImg" style="width: 80px; height: 80px" />
        </template>
      </el-table-column>
      <el-table-column label="重量(KG)" width="80" align="center" prop="weight"/>
      <el-table-column label="价格(元)" width="80" align="center" prop="price"/>
      <el-table-column label="操作" width="width" align="center">
        <!-- 操作部分：有5个按钮 -->
        <template slot-scope="{ row, $index }">
          <el-button v-if="row.isSale === 1"  type="warning"  icon="el-icon-bottom"
 size="mini" @click="cancel(row)"/>
          <el-button v-else  type="success" icon="el-icon-top" size="mini" @click="sale(row)"/>
          <el-button type="primary" icon="el-icon-edit" size="mini" @click="getSkuInfo(row)" />
          <el-button type="info" icon="el-icon-info" size="mini" @click="edit"/>
          <el-button type="danger" icon="el-icon-delete" size="mini" />
        </template>
      </el-table-column>
    </el-table>
```

#### 3.分页器使用

和之前模块写的分页器一样，先写静态然后获取数据后改成动态数据，最后就是分页器两个重要的方法，一个是页码改变一个是每页条数改变，这里的逻辑就是先获取到最新的参数，再去重新发请求

（1）分页器静态

```js
<!-- 分页器 -->
    <el-pagination
      style="text-align: center"
      :total="total"
      :current-page="page"
      :page-size="limit"
      :page-sizes="[3, 5, 10]"
      layout="prev,pager,next,jumper,->,sizes,total"
      @size-change="handleSizeChange"
      @current-change="getSkuList"
    />
```

（2）分页器页码变化的回调

```js
@current-change="getSkuList"
// 这里和获取sku列表使用的是一个函数，只是需要将最新的参数传递进入
// 发请求获取sku列表数据
    async getSkuList(pages = 1) {
      // 这样页码改变时也能获取到相应得数据
      this.page = pages
      // 解构出参数
      const { page, limit } = this
      const result = await this.$API.sku.reqSkuList(page, limit)
      this.records = result.data.records
      this.total = result.data.total
    },
```

（3）每页展示条数变化的回调

```js
@size-change="handleSizeChange" 
// 当每页展示条数改变时触发的回调
    handleSizeChange(limit) {
      this.limit = limit
      this.getSkuList()
    },
```

#### 3.上下架按钮显示及操作

这里需要注意`isSale和图标展示`的对应关系，isSale=1代表上架状态，只能操作下架，则应该展示下架的图标，为0代表下架状态，可以操作上架，显示上架的图表，都有对应的接口去发请求即可，同时将属性值进行修改

（1）上架操作

```js
 <el-button v-else  type="success" icon="el-icon-top" size="mini" @click="sale(row)"/>
 
 // sku上架的接口
// url:/admin/product/onSale/{skuId}    get
export const reqSale = (skuId) => request({
  url: `/admin/product/onSale/${skuId}`,
  method: 'get'
})

// 上架的回调
    async sale(row) {
      // 发请求上架，只有目前显示上架按钮的row才能上架
      const result = await this.$API.sku.reqSale(row.id)
      if (result.code === 200) {
        // 将属性改成1，显示向下的箭头
        row.isSale = 1
        this.$message({ type: 'success', message: '上架成功' })
      }
    },
```

（2）下架操作

```js
<el-button v-if="row.isSale === 1"  type="warning"  icon="el-icon-bottom"
 size="mini" @click="cancel(row)"/>
 
 // sku下架的接口
// ulr:/admin/product/cancelSale/{skuId}   get
export const reqCancel = (skuId) => request({
  url: `/admin/product/cancelSale/${skuId}`,
  method: 'get'
})

// 下架的回调
async cancel(row) {
  const result = await this.$API.sku.reqCancel(row.id)
  if (result.code === 200) {
    // 将属性值改为0，显示向上的箭头
    row.isSale = 0
    this.$message({ type: 'success', message: '下架成功' })
  }
},
```

#### 4.sku详情查看的抽屉结构

（1）获取sku详情的接口

```js
// 获取sku详情的接口
// url: /admin/product/getSkuById/{skuId}   get
export const reqSkuById = (skuId) => request({
  url: `/admin/product/getSkuById/${skuId}`,
  method: 'get'
})
```

（2）发请求获取sku数据

```js
// 获取sku详情的方法
    async getSkuInfo(row) {
      this.drawer = true
      const result = await this.$API.sku.reqSkuById(row.id)
      // console.log(result)
      if (result.code === 200) {
        this.skuInfo = result.data
      }
    },
```

（3）静态结构生成并使用数据

抽屉内使用layout布局，将其分成5，16，3三部分，因为前面已经将数据存储在data中，所以直接插值语法使用即可，需要注意的是平台属性这里`内嵌tag标签`，遍历出所有的数据，但有的spu没有这个属性，展示不出来也是正常的，商品图片部分使用`轮播图结构`，记住对图片的样式做个优化，让整体更加美观

```js
 <el-drawer :visible.sync="drawer" :show-close="false" size="50%">
      <!-- 内部使用layout布局 -->
      <el-row>
        <el-col :span="5">名称</el-col>
        <el-col :span="16">{{ skuInfo.skuName }}</el-col>
      </el-row>
      <el-row>
        <el-col :span="5">描述</el-col>
        <el-col :span="16">{{ skuInfo.skuDesc }}</el-col>
      </el-row>
      <el-row>
        <el-col :span="5">价格</el-col>
        <el-col :span="16">{{ skuInfo.price }}元</el-col>
      </el-row>
      <el-row>
        <el-col :span="5">平台属性</el-col>
        <el-col :span="16">
          <template>
            <el-tag
              v-for="(attr, index) in skuInfo.skuAttrValueList"
              :key="attr.id"
              style="margin-right: 10px"
              type="success"
              >{{ attr.attrId }}-{{ attr.attrName }}</el-tag >
          </template>
        </el-col>
      </el-row>
      <el-row>
        <el-col :span="5">商品图片</el-col>
        <el-col :span="16">
          <template slot-scope="">
            <el-carousel height="200px">
              <el-carousel-item
                v-for="item in skuInfo.skuImageList"
                :key="item" >
                <img :src="item.imgUrl" style="width: 200px; height: 200px" />
              </el-carousel-item>
            </el-carousel>
          </template>
        </el-col>
      </el-row>
    </el-drawer>
```

轮播图样式

```css
<style>
.el-carousel__item:nth-child(2n) {
  /* background-color: #99a9bf; */
  text-align: center;
}

.el-carousel__item:nth-child(2n + 1) {
  /* background-color: #d3dce6; */
  text-align: center;
}
</style>

<style scoped>
.el-row .el-col-5 {
  font-size: 18px;
  text-align: right;
  font-weight: 600;
}
.el-col {
  margin: 10px;
}

>>> .el-carousel__button {
  width: 10px;
  height: 10px;
  background-color: red;
  border-radius: 50%;
}
</style>

```

#### 5.深度选择器

（1）scoped属性的作用

加上scoped的作用是只对当前的组件有用（样式）

对于某一个组件，如果style添加上scoped属性，给当前子组件的结构中都添加上了一个 data-v-xxx自定义属性

vue是通过属性选择器，给需要添加的元素添加上样式

子组件的跟标签也会拥有父组件当中的自定义属性，是一样的，如果子组件的根节点和父组件中书写的样式相同，也会添加上相同的样式，再里面的层级则不会进行匹配了

```js
// 父组件
<div>
   <h3>我是父组件，字体是红色的 </h3>
</div>

// 子组件情况1
<div>
   <h3>我是子组件，只有外侧的div会继承父组件的自定义属性，我不是红色的h3 </h3>
</div>

// 子组件情况2
<h3>我是子组件，外侧没有div的清空下，会继承父组件的自定义属性，变成红色的h3 </h3>
```

（2）深度选择器

如果父组件的样式（scoped）,但还是想影响子组件的结构，则需要使用深度选择器

深度选择器可以实现样式穿透

- 原生css  >>>

- less  /deep/

- sass   ::


## 8、数据可视化学习

#### 1.canvas介绍

- canvas画布：是HTML5中新增的特性，`双闭合便签`
- canvas标签默认宽度和高度，`300*150`
- 浏览器认为canvas标签是一张`图片`，可以保存到本地
- 是标签就可以写css样式，给canvas画布添加文本内容是没有任意意义的（不会显示）
- 给canvas标签添加子节点也是没有意义的（不会显示）
- 想操作canvas画布：在画布中绘制图形，显示文字等，都需要通过`js完成`
- canvas标签的宽度|高度务必通过canvas标签属性 `width |height`设置

```js
// 切记不能通过样式去设置canvas的宽度|高度
<canvas width='600' height='300'> </canvas>
```

#### 2.绘制线段

```js
     // canvas标签任何操作务必通过JS完成
        // 通过JS中的“笔”去完成
        // 1.获取canvas元素
        let canvas = document.querySelector('canvas')
        // 获取画布的笔【上下文】
        let ctx = canvas.getContext('2d')
        // 2.绘制线段：绘制线段的起点的设置
        ctx.moveTo(100, 100)
        // 其他点的设置
        ctx.lineTo(200, 200)
        ctx.lineTo(100, 200)
        // 3.设置图形填充及填充颜色
        ctx.fillStyle = '#bfc'
        ctx.fill()
        // 4.设置线段的颜色及宽度
        ctx.strokeStyle = 'red'
        ctx.lineWidth = '5'
        // 5.设置起点与最终的结束点链接在一起
        ctx.closePath()
        // 6.stroke方法绘制线段
        ctx.stroke()
```

#### 3.绘制矩形

```js
        // 获取节点
        let canvas = document.querySelector('canvas')
        // 获取上下文
        let ctx = canvas.getContext('2d')
        // 绘制矩形的第一种方式---只能描边不能填充颜色
        // 参数说明：x y 宽度 高度
        ctx.strokeRect(100, 200, 100, 200)
        // 第二种方式
        // 参数说明同上
        // 填充颜色可以替换
        // 绘制图形之前设置填充颜色
        ctx.fillStyle = "yellow"
        ctx.fill()
        ctx.fillRect(300, 200, 100, 200)
```

#### 4.绘制圆形

arc(x,y,radius,starAngle,endAngle,anticclockwise)

x：圆心的X坐标

y：圆心的Y坐标

radius ：圆形的半径

starAngle：开始角度

endAngle：结束角度

anticclockwise：是否逆时针绘制，true逆时针 false顺时针

```js
        // 获取节点
        let canvas = document.querySelector('canvas')
        // 获取上下文
        let ctx = canvas.getContext('2d')
        // 绘制圆形
        ctx.beginPath()
        // 绘制圆形的方法：x,y,radius,起始弧度，结束弧度,是否逆时针绘制
        //  360° = 2 * PI *弧度
        ctx.arc(100, 100, 50, 0, 2 * Math.PI, true)
        // 设置填充颜色
        ctx.fillStyle = 'red'
        ctx.fill()
        // 绘制圆形
        ctx.stroke()
```

#### 5.绘制文字

注意：画布的宽度和高度通过属性设置，千万不要通过样式设置，会导致坐标系混乱

```js
        // 获取节点
        let canvas = document.querySelector('canvas')
        // 获取上下文-笔
        let ctx = canvas.getContext('2d')
        ctx.fillRect(100, 200, 100, 200)
        // 清除画布全部内容
        // ctx.clearRect(0, 0, 600, 400)
        // 清除部分矩形
        ctx.clearRect(100, 200, 50, 100)
        // 设置字体
        ctx.font = "20px 微软雅黑"
        // 设置字体颜色
        ctx.fillStyle = 'red'
        // 绘制文字
        ctx.fillText('数据可视化', 50, 100)
```

#### 6.绘制柱状图

注意：坐标起点是左上角的0，0，要认真计算每次的坐标

```js
       // 获取节点
        let canvas = document.querySelector('canvas')
        // 获取上下文
        let ctx = canvas.getContext('2d')
        // 设置字体
        ctx.font = "16px 微软雅黑"
        // 绘制文字
        ctx.fillText('数据可视化', 50, 50)
        // 绘制线段---x和y轴
        ctx.moveTo(100, 100)
        ctx.lineTo(100, 400)
        ctx.lineTo(700, 400)
        ctx.stroke()

        // 绘制其他线段
        ctx.moveTo(90, 100)
        ctx.lineTo(700, 100)
        ctx.fillText('150', 55, 106)

        ctx.moveTo(90, 160)
        ctx.lineTo(700, 160)
        ctx.fillText('120', 55, 166)


        ctx.moveTo(90, 220)
        ctx.lineTo(700, 220)
        ctx.fillText('90', 64, 226)


        ctx.moveTo(90, 280)
        ctx.lineTo(700, 280)
        ctx.fillText('60', 64, 286)


        ctx.moveTo(90, 340)
        ctx.lineTo(700, 340)
        ctx.fillText('30', 64, 346)
        ctx.fillText('0', 75, 405)


        ctx.stroke()


        // 绘制水平坐标轴底部的线段
        ctx.moveTo(250, 400)
        ctx.lineTo(250, 410)

        ctx.fillText('食品', 166, 418)


        ctx.moveTo(400, 400)
        ctx.lineTo(400, 410)
        ctx.fillText('数码', 316, 418)


        ctx.moveTo(550, 400)
        ctx.lineTo(550, 410)
        ctx.fillText('服饰', 466, 418)
        ctx.fillText('箱包', 616, 418)

        ctx.stroke()

        // 绘制矩形
        ctx.fillStyle = 'red'
        // ctx.fill()
        ctx.fillRect(120, 200, 110, 200)
        ctx.fillRect(270, 300, 110, 100)
        ctx.fillRect(420, 100, 110, 300)
        ctx.fillRect(570, 150, 110, 250)
```

![下载](https://raw.githubusercontent.com/Grayoul/cloudimg/master/data202207251657590.png)

#### 7.svg矢量图

放大不失真，但兼容性较差（IE8以下不兼容）

```js
 <!-- svg双闭合标签：默认宽度和高度 300 150  svg绘制图形务必在svg标签内部使用绘制图形 -->
    <svg class="box">
        <!-- x1 y1 第一个点的坐标  x2 y2 第二个点的坐标 -->
        <!-- stroke-width:线的宽度设置  stroke：线的颜色-->
        <line x1="100" y1='100' x2="200" y2="200" stroke="red" stroke-width="5px"></line>
        <line x1="200" y1='100' x2="100" y2="200" stroke="red"></line>
        <!-- 绘制折线：可以多个点，最好带有逗号更清晰 -->
        <!-- fill-opacity：是否有颜色填充  stroke：线的颜色-->
        <polyline points="300 300 ,50 200 ,120 400,20,350" fill-opacity="0" stroke="red"></polyline>
        <!-- 绘制矩形 -->
        <!-- fill:设置填充的颜色  stroke：线的颜色-->
        <rect x="400" y="200" width="200" height="100" fill="pink" stroke="black"></rect>
        <!-- 绘制圆形 -->
        <!-- cx：圆心的x坐标  cy:圆心的y坐标 -->
        <circle cx="370" cy="95" r="50" style="stroke: black;fill:pink"></circle>
        <!-- 绘制椭圆 -->
        <!-- rx：x轴半径   ry：y轴半径 -->
        <ellipse cx="500" cy="95" rx="50" ry="80" style="stroke: black;fill:pink"></ellipse>
        <!-- 多边形 -->
        <polygon points="600 100,700 300,750 200" stroke="#bfa" fill-opacity="0"></polygon>
        <!-- 绘制任意图形 -->
        <path stroke="#bfa" fill-opacity="0" d="
                M 210 10
                L 320 400
                L 130 120 
                L 440 90
                L 279 82
                L 160 120
                L 120 30
               Z"></path>
    </svg>
```

#### 8.ECharts入门

（）echarts引用

```js
// 安装命令
npm i --save echarts
// 引用
import * as echarts from 'echarts';
```

（2）创建echarts

```js
<body>
    <!-- 准备一个容器：容器就是显示图表的区域 -->
    <div class="box1"></div>
    <script>
        // 基于准备好的dom，初始化echarts实例
        let dom1 = document.querySelector('.box1')
        //  初始化echarts实例
        let mycharts1 = echarts.init(dom1)
        // 指定图表的配置项和数据
        mycharts1.setOption({
            // 标题
            title: {
                // 主标题
                text: '数据可视化',
                // 子标题
                subtext: 'ECharts基本使用',
                // 标题的颜色
                textStyle: {
                    color: 'orange'
                },
                left: 'center'
            },
            // X轴的配置项
            xAxis: {
                // 数据
                data: ['吃饭', '看书', '逛街']
            },
            // Y轴的配置项
            yAxis: {
                // 显示Y轴的线
                axisLine: {
                    show: 'true'
                },
                axisTick: {
                    show: 'true'
                }
            },
            // 系列的设置：图表类型，数据展示
            series: [{
                name: '销量',
                // 图表类型的设置
                type: 'bar',
                // 图表的数据
                data: [5, 20, 36, 10, 10, 20],
                color: 'red',

            }]
        })
    </script>
</body>
```

## 9、首页可视化展示

#### 1.框架拆分

根据页面布局可以将首页拆分成3个部分，分别为`card,sale和observe`三个组件，内部再进行细节规划

| <Card /> | <Sale /> | <Observe /> |
| -------- | -------- | ----------- |

```js
<template>
  <div>
    <Card />
    <Sale />
    <Observe />
  </div>
</template>

<script>
import Card from './card'
import Sale from './Sale'
import Observe from './Observe'
export default {
  name: 'Dashboard',
  components: { Card, Sale, Observe },
  mounted() {
    // 派发action,获取home的模拟数据
    this.$store.dispatch('getData')
  },
}
</script>
```

#### 2.card组件

（1）页面布局规划

为提高组件复用性，将顶部card组件再拆分成单个组件<Detail />，寻找其共同性，将每个卡片拆分成 头部 内容区 图表区 和底部区域，通过props传递简单参数，通过插槽呈现复杂的结构。同时采用layput布局，将此部分拆分成24份，每个卡片占6份，同时能符合响应式布局

布局样式：`layout，每份占6，内嵌card组件，再结合<Detail/>组件`

```js
<el-row :gutter="10" style="margin-top: 10px">
      <el-col :span="6">
        <el-card>
           <Detail><Detail/>
        </el-card>
      </el-col>
</el-row>
```

Detail结构：

| 每个card的Detail接收信息并使用  | 父组件传递内容                             |
| ------------------------------- | ------------------------------------------ |
| card-header: title  svg         | <Detail title="总销售额" count="￥126560"> |
| card-content:  count            | <Detail title="总销售额" count="￥126560"> |
| card-chart : 放echarts图表      | <template slot="charts">·····</template>   |
| card-footer: 放横线下的底部信息 | <template slot="footer">······</template>  |

```js
<template>
  <!-- 此文件为cart组件内每个详情展示的模板，里面可以更换信息 -->
  <div>
    <div class="card-header">
      <!-- 标题 -->
      <span>{{ title }}</span>
      <!-- 矢量图 -->
      <svg></svg>
    </div>
    <!-- card内容 -->
    <div class="card-content">{{ count }}</div>
    <!-- card图表 -->
    <div class="card-chart">
      <slot name="charts" />
    </div>
    <!-- card底部 -->
    <div class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>

```

（2）访问量折线图

**注意渐变色和平滑曲线的设置**

```js
<template slot="charts">
     <lineChart
        v-if="listState.visitTrend"
         :visittrend.sync="listState.visitTrend"/>
</template>
 

 <lineChart
         v-if="listState.visitTrend"
         :visittrend.sync="listState.visitTrend" />

// mounted中获取echarts节点，初始化并设置选项
// 初始化echarts实例
 mounted() {
    const lineChart = echarts.init(this.$refs.charts)
    // 配置数据
    lineChart.setOption({
    ·····
    })
 } 

***注意点***
// 配置数据
    lineChart.setOption({
      xAxis: {
        // 隐藏x轴
        show: false,
        type: 'category', // 数据可以均匀分布
      },
      series: [
        {
          type: 'line',
          smooth: true, // 折线就是光滑的了
          data: this.$props.visittrend,
          //   拐点的样式设置
          itemStyle: {
            opacity: 0,
          },
          //   线条的样式
          lineStyle: {
            color: '#9572e0',
          },
          //   填充区域的颜色
          areaStyle: {
            color: {
              type: 'linear',
              x: 0,
              y: 0,
              x2: 0,
              y2: 1,
                //设置渐变色
              colorStops: [
                {
                  offset: 0,
                  color: '#9572e0', // 0% 处的颜色
                },
                {
                  offset: 1,
                  color: '#fff', // 100% 处的颜色
                },
 			······
```

组件内使用

```js
<Detail title="访问量" :count="listState.visitTotal">
      <template slot="charts">
        <lineChart
          v-if="listState.visitTrend"
          :visittrend.sync="listState.visitTrend"
        />
      </template>
      <template slot="footer">
        <span>日访问量 {{ listState.visitToday }}</span>
      </template>
</Detail>
```

（3）支付笔数柱状图

```js
 <barChart
      v-if="listState.payTrend"
      :paytrend="listState.payTrend"
    />

mounted() {
    // 配置数据
    lineChart.setOption({
      xAxis: {
        //   隐藏x轴
        show: false,
        // 均分
        type: 'category',
        // 数据
        data: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      yAxis: {
        show: false,
      },
      series: [
        {
          type: 'bar',
          data: this.$props.paytrend,
        },
      ],
      //   布局调试
      grid: {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
      },
      // 点击每个item显示提示
      tooltip: {},
    })
  },
```

组件内使用

```js
<Detail title="支付笔数" :count="listState.payTotal">
      <template slot="charts">
        <barChart
          v-if="listState.payTrend"
          :paytrend="listState.payTrend"
        />
      </template>
      <template slot="footer">
        <span>转化率 {{ listState.payRate }}%</span>
      </template>
</Detail>
```

（4）运营活动效果进度条

使用的是柱状图（借助min  max设置实现进度条效果），改变展示方向（`yAxis===type: 'category'`），设置宽度（series===barWidth: 10,），颜色和背景色，最后设置文本，在右侧展示 | 竖线

```js
    // 配置数据
    lineChart.setOption({
      xAxis: {
        //   隐藏x轴
        show: false,
        // 最小值与最大值的设置
        min: 0,
        max: 100,
      },
      yAxis: {
        show: false,
        // 均分同时改变了柱状图的展示方向
        type: 'category',
      },
      series: [
        {
          type: 'bar',
          data: [78],
          // 设置柱状图的宽度
          barWidth: 10,
          color: 'yellowgreen',
          // 背景颜色设置
          showBackground: true,
          // 设置背景颜色
          backgroundStyle: {
            color: '#eee',
          },
          // 文本设置
          label: {
            show: true,
            // 改变文本内容
            formatter: '|',
            // 设置标签位置
            position: 'right',
            fontWeight: 'bold',
          },
        },
      ],
      })
```

组件内使用

~~~js
<Detail title="运营活动效果" :count="listState.activityRate">
          <template slot="charts">
            <progressChart
              v-if="listState.activityRate"
              :count.sync="listState.activityRate"
            />
          </template>
          <template slot="footer">
            <span
              >周同比{{ listState.activityGrowthLastMonth }}%<svg
                ```
              >
                <path
                  d="M512 405.333333L298.666667 618.666667h426.666666L512 405.333333z"
                  fill="#1afa29"
                  p-id="2328"
                />
              </svg>
            </span>
            &nbsp;&nbsp;&nbsp;&nbsp;
            <span
              >日同比 {{ listState.activityGrowthLastDay }}%<svg
 				````
              >
                <path
                  d="M512 618.666667L298.666667 405.333333h426.666666L512 618.666667z"
                  fill="#d81e06"
                  p-id="1308"
                /></svg
            ></span>
          </template>
        </Detail>
~~~

#### 3.sale组件

| **上半部分  div 布局**   |                              |                |
| ------------------------ | ---------------------------- | -------------- |
| el-tabs                  | 日期切换                     | el-date-picker |
| 销售量  \| 访问量        | 今日 \| 本周 \| 本月 \| 本年 | 日历组件       |
| **下半部分 el-row 布局** |                              |                |
| charts                   |                              | div            |
| 放图表                   |                              | 品牌排名       |

（1）tab切换部分

- activeName属性， 默认值是销售额  `activeName: 'sale'` 
- 此属性决定title  `this.activeName === 'sale' ? '销售额' : '访问量'`
- title会决定图表显示的数据，从而达到切换tab，显示不同图表的效果

需要注意mounted中创建一个空的图表，第一次没有数据所以不显示，再结合watch监视title变化，加载不同的图表，有新数据用新的，没有就用之前的数据**【一个图表，切换里面展示的数据】**

```js
//  activeName: 'sale',  默认销售额有类名,类名决定title,title会决定最终显示哪个图表
<el-tabs v-model="activeName" class="tab">
        <el-tab-pane label="销售额" name="sale" />
        <el-tab-pane label="访问量" name="visite" />
</el-tabs>

// 计算属性-右侧排名的标题
    title() {
      return this.activeName === 'sale' ? '销售额' : '访问量'
    },
        
 // 根据标题展示不同数据
     xAxis: {
          // 根据标题展示不同数据
          data:
            this.title === '销售额'
              ? this.liststate.orderFullYearAxis
              : this.liststate.userFullYearAxis,
        },
```

（2）日期选择插件

引入elementUI的日期插件 `<el-date-picker>`，配合span点击事件，达到日期的切换功能

```js
<!-- 头部右侧内容 -->
      <div class="right">
        <span @click="setDay">今日</span>
        <span @click="setWeek">本周</span>
        <span @click="setMonth">本月</span>
        <span @click="setYear">本年</span>
        <el-date-picker
          v-model="date"
          class="date"
          type="daterange"
          range-separator="-"
          start-placeholder="开始日期"
          end-placeholder="结束日期"
          size="mini"
          value-format="yyyy-MM-dd"
        />
      </div>
```

（3）dayjs插件使用

获取当天的日期 ，借助`dayjs`插件  

```js
npm i --save dayjs 
```

使用dayjs身上方法设置`本日，本周，本月和本年的数据`，再将此数据赋值给准备好的日历数组对象，这样日历就会展示对应的日期了

```js
import dayjs from 'dayjs'
data() {
    return {
      // 收集日历数据
      date: [],
    }
  },
  
 methods: {
    // 今日时间的设置
    setDay() {
        // 格式化
      const day = dayjs().format('YYYY-MM-DD')
      // 日历需要两个日期
      this.date = [day, day]
    },
    // 本周
    setWeek() {
      const start = dayjs().day(1).format('YYYY-MM-DD')
      const end = dayjs().day(7).format('YYYY-MM-DD')
      this.date = [start, end]
    },
    // 本月
    setMonth() {
      const start = dayjs().startOf('month').format('YYYY-MM-DD')
      const end = dayjs().endOf('month').format('YYYY-MM-DD')
      this.date = [start, end]
    },
    // 本年
    setYear() {
      const start = dayjs().startOf('year').format('YYYY-MM-DD')
      const end = dayjs().endOf('year').format('YYYY-MM-DD')
      this.date = [start, end]
    },
  },  
```

（4）排名榜

这里需要根据不同的title展示对应内容，使用`h3+ul`结构，通过`v-if="title === '销售额'"`控制显示哪个ul，实现动态切换效果，前3个序号有特殊样式，这里需要添加动态类名完成，语法：`:class="order.no < 4 ? 'rindex' : 'rspan'"`

```js
<!-- 排行榜 -->
    <div class="content">
      <el-row :gutter="10">
        <el-col :span="18">
          <div ref="charts" class="charts" />
        </el-col>
        <el-col :span="6">
          <div>
            <h3>品牌{{ title }}排名</h3>
            <ul v-if="title === '销售额'">
              <li v-for="(order, index) in liststate.orderRank" :key="order.id">
                <span :class="order.no < 4 ? 'rindex' : 'rspan'">{{
                  order.no
                }}</span>
                <span>{{ order.name }}</span>
                <span class="rvalue">{{ order.money }}</span>
              </li>
            </ul>
            <ul v-if="title === '访问量'">
              <li v-for="(user, index) in liststate.userRank" :key="user.id">
                <span :class="user.no < 4 ? 'rindex' : 'rspan'">{{
                  user.no
                }}</span>
                <span>{{ user.name }}</span>
                <span class="rvalue">{{ user.money }}</span>
              </li>
            </ul>
          </div>
        </el-col>
      </el-row>
    </div>
```

#### 4.Observe模块

此部分分为左右线上搜索和销售额两个模块，每个模块再根据展示需求进行细化拆分

| el-col :span="12" ：线上热门搜索                             | el-col :span="12":销售额类别占比 |
| ------------------------------------------------------------ | -------------------------------- |
| header：展示 线上热门搜索 标题  和 查看更多图标              |                                  |
| context：layout布局，呈现2个图标，再放div展示table           |                                  |
| content：table表格展示 searchWord数据，这里存在的问题：分页器配置limit后table未生效 |                                  |

（1）线上搜索模块

分为头部和内容区，需要获取动态数据

```js
// 整理数据格式，生成用户数的新数组
newarry() {
      this.$props.list.searchWord.forEach((item) => {
        this.userarry.push(item.user)
      })
      // console.log(this.userarry)
      return this.userarry
    },
             
```

（2）table表格

```js
// 先获取首页全部数据，再计算出搜索词的数据进行使用
computed: {
    // home首页的全部数据
    ...mapState({
      list: (state) => state.home.list,
    }),
    // 关键字数据
    search() {
      return this.list.searchWord
    },
  },
```

（3）销售额模块

整理线上和门店的数据格式，服务器返回的是对象里套数组，分别为value和name，而图表需要的是数组里面套对象，有value和name属性，先准备一个空数组，然后通过for循环遍历数组，因为相同索引值对应的value和name是一组，可以通过item进行接收生成新的元素，再push进提前准备好的数组里，这样图表需要的格式就整理好了

```js
online() {
      const arry = []
      for (let index = 0; index < this.saleList.online.name.length; index++) {
        const item = {
          value: this.saleList.online.value[index],
          name: this.saleList.online.name[index],
        }
        arry.push(item)
      }
      return arry
    },
    shop() {
      const arry = []
      for (let index = 0; index < this.saleList.shop.name.length; index++) {
        const item = {
          value: this.saleList.shop.value[index],
          name: this.saleList.shop.name[index],
        }
        arry.push(item)
      }
      return arry
    },
```

这里需要注意：切换tab时需要展示不同的图表，可以mounted初始化时data为空，对options的value值进行watch，重新set图表，根据value显示不同的data数据，这样就可以达到切换tab时显示不同的类型的数据

```js
watch: {
    // 监听图表标题
    value() {
      this.mycharts1.setOption({
        title: {
          text: this.value,
          // subtext: 1048,
          left: 'center',
          top: 'center',
        },
        tooltip: {
          trigger: 'item',
        },
        series: [
          {
            type: 'pie',
            radius: ['40%', '70%'],
            avoidLabelOverlap: false,
            label: {
              show: true,
              position: 'outside',
            },
            labelLine: {
              show: true,
            },
            // 根据标题展示不同数据
            data: this.value === '线上' ? this.online : this.shop,
          },
        ],
      })
    },
  },
  mounted() {
    // 饼图
    this.mycharts1 = echarts.init(this.$refs.charts1)
    this.mycharts1.setOption({
      title: {
        text: '线上销售额',
        // subtext: 1048,
        left: 'center',
        top: 'center',
      },
      tooltip: {
        trigger: 'item',
      },
      series: [
        {
          type: 'pie',
          radius: ['40%', '70%'],
          avoidLabelOverlap: false,
          label: {
            show: true,
            position: 'outside',
          },
          labelLine: {
            show: true,
          },
          // 根据标题展示不同数据
          // data: this.value === '线上' ? this.online : this.shop,
          data: [
            // { value: 1048, name: '家用电器' },
            // { value: 735, name: '食用酒水' },
            // { value: 580, name: '个护健康' },
            // { value: 484, name: '服饰箱包' },
            // { value: 300, name: '母婴产品' },
            // { value: 143, name: '其他' },
          ],
        },
      ],
    })
    // 给图表绑定事件
    mycharts1.on('mouseover', (params) => {
      // 获取鼠标移上去的那条数据
      const { name, value } = params.data
      // 重新设置标题
      mycharts1.setOption({
        title: {
          text: name,
          subtext: value,
        },
      })
    })
  },
```

#### 5.动态展示mock数据

引入 data.json，创建home.js 去获取首页全部存储到vuex中，方便首页内各子组件的获取存储相应的数据

（1）mock文件夹的`index.js`引入 

```c
const home = require('./home')

const mocks = [
  ...user,
  ...table,
  ...home
]
```

（2）修改mock文件夹中de `mock-serve`中配置

```c
url: new RegExp(`${process.env.VUE_APP_MOCK_API}${url}`),
```

（3）`env中`加入mock地址的配置   

```c
# base api
VUE_APP_BASE_API = '/dev-api'
VUE_APP_MOCK_API = '/mock-api'
```

（4）`vue.config`中共开启mock数据配置的，如果写before会出现超时错误，改成after可解决

```c
// 开启mock数据
  after: require('./mock/mock-server')
```

（5）utils文件中创建`requestmock`请求文件---修改baseURL

```
baseURL: process.env.VUE_APP_MOCK_API, 
```

（6）store文件的`home.js`使用

```js
import requestmock from '@/utils/requestmock'
const state = {
  list: {}
}
const mutations = {
  GETDATA(state, list) {
    state.list = list
  }
}
const actions = {
  // 发请求获取首页的mock数据
  async getData({
    commit
  }) {
    const result = await requestmock.get('/home/list')
    if (result.code === 20000) {
      commit('GETDATA', result.data)
    }
  }
}
```

## 10、权限管理之用户管理

#### 1.头部form和按钮

```js
<!-- 头部 -->
    <el-form inline>
      <!-- 表单元素 行内表单-->
      <el-form-item style="margin-top: 20px">
        <el-input v-model="tempSearchObj.username" placeholder="用户名" />
      </el-form-item>
      <!-- 查询与清空的按钮 -->
      <el-button
        type="primary"
        icon="el-icon-search"
        style="margin-top: 20px"
        @click="search"
        >查询</el-button
      >
      <el-button type="default" style="margin-top: 20px" @click="resetSearch"
        >清空</el-button
      >
    </el-form>
```

（1）查询回调

```js
// 头部搜索按钮的回调，根据输入的内容进行搜索
    search() {
      // 浅拷贝放置数据较多，还没查看完用户重新输入文字导致后面的数据无法查看，不让两者互相影响，用一个新的变量进行接收
      // tempSearchObj收集输入框的数据  searchObj收集查询按钮的数据
      this.searchObj = { ...this.tempSearchObj }
      this.getUsers()
    },
```

（2）清空回调

```js
 // 清空输入后搜索,需要将输入框和按钮的搜索对象都清空，避免出现数据不一致的清空
    resetSearch() {
      // 搜索对象清空，不清的话table里还会展示
      this.searchObj = {username: '',}
      // 点击查询的对象清空，不清空的话输入框里还有此信息
      this.tempSearchObj = {username: '',}
      // 重新获取用户数据
      this.getUsers()
    },
```

#### 2.添加和删除按钮区域

```js
<!-- 按钮区域 -->
    <div style="margin-bottom: 20px">
      <!-- 添加与批量添加按钮 -->
      <el-button type="primary" @click="showAddUser">添 加</el-button>
      <el-button
        type="danger"
        :disabled="selectedIds.length === 0"
        @click="revomveUsers"
        >批量删除</el-button
      >
    </div>
```

（1）添加用户回调

首先是弹出对话框，可以输入用户名，昵称和密码，保存的时候将数据发给服务器，取消就清空已输入的信息并关闭对话框

```js
// 显示添加用户的界面
    showAddUser() {
      // 清空解决数据回显问题
      this.user = {}
      // 让对话框显示
      this.dialogUserVisible = true
      // 发请求-移除该表单项的校验结果
      this.$nextTick(() => this.$refs.userForm.clearValidate())
    },
        
<!-- 添加|修改用户的对话框的结构，通过是否有id进行区分 -->
    <el-dialog
      :title="user.id ? '修改用户' : '添加用户'"
      :visible.sync="dialogUserVisible"
    >
      <el-form ref="userForm" :model="user" :rules="userRules" label-width="120px">
        <el-form-item label="用户名" prop="username">
          <el-input v-model="user.username" />
        </el-form-item>
        <el-form-item label="用户昵称">
          <el-input v-model="user.nickName" />
        </el-form-item>
       // 只有添加用户时候显示此item,修改用户信息不显示
        <el-form-item v-if="!user.id" label="用户密码" prop="password">
          <el-input v-model="user.password" />
        </el-form-item>
      </el-form>
      //按钮区域
      <div slot="footer" class="dialog-footer">
        <el-button @click="cancel">取 消</el-button>
        <el-button :loading="loading" type="primary" @click="addOrUpdate"
          >确 定</el-button
        >
      </div>
    </el-dialog>
```

（2）取消添加

```js
cancel() {
    // 关闭添加|更新的对话框
      this.dialogUserVisible = false
    // 清空数据
      this.user = {}
    },
```

（3）确定添加

```js
addOrUpdate() {
    // 表单验证
      this.$refs.userForm.validate((valid) => {
          // 验证成功
        if (valid) {
          const { user } = this
          // loading开始
          this.loading = true
            // 发请求
          this.$API.user[user.id ? 'update' : 'add'](user).then((result) => {
              // loading结束
            this.loading = false
            this.$message.success('保存成功!')
              // 重新获取数据，添加成功跳转第一页，更新成功留在当前页
            this.getUsers(user.id ? this.page : 1)
              //清空数据
            this.user = {}
              // 关闭对话框
            this.dialogUserVisible = false
          })
        }
      })
    },
```

（4）批量删除功能

没有选中数据时按钮无法使用，至少选中1条数据才能使用（调用接口通过id进行删除），这里的id时通过复选框变化时进行收集的

```js
// 删除所有选中的用户
    revomveUsers() {
      this.$confirm('确定删除吗?')
        .then(async () => {
          // 发请求删除
          await this.$API.user.removeUsers(this.selectedIds)
          // 提示删除成功
          this.$message.success('删除成功')
          this.getUsers()
        })
        .catch(() => {
          this.$message.info('取消删除')
        })
    },

// 接口批量删除多个用户
// ids的结构: ids是包含n个id的数组

export function removeUsers(ids) {
  return request({
    url: `${api_name}/batchRemove`,
    method: 'delete',
    data: ids
  })
}
```

#### 3.用户信息table及功能

需要注意的是，第一列需要设置为复选框，最后一列操作，需要使用带提示的button组件，点击后弹出相应的组件进行权限分配，信息查询等

（1）tbale静态结构

```js
<!-- table表格：展示用户信息的地方 -->
    <el-table
      v-loading="listLoading"  border stripe :data="users"
      @selection-change="handleSelectionChange"
    >
     此处为每列展示数据的配置······
      <el-table-column label="操作" width="230" align="center">
        <template slot-scope="{ row }">
            // 封装后的button，会有hover提示功能
          <HintButton  type="info" size="mini"  icon="el-icon-user-solid"
            title="分配角色" @click="showAssignRole(row)"/>
          <HintButton type="primary"  size="mini" icon="el-icon-edit"
            title="修改用户" @click="showUpdateUser(row)"/>
          <!-- 删除确定框 -->
          <el-popconfirm
            :title="`确定删除 ${row.username} 吗?`"
            @onConfirm="removeUser(row.id)"
          >
            <HintButton slot="reference" style="margin-left: 10px" type="danger" size="mini" icon="el-icon-delete"  title="删除用户"/>
          </el-popconfirm>
        </template>
      </el-table-column>
    </el-table>
```

（2）修改用户

这里和添加用户使用的是一套流程，通过是否有id进行判断，区分就是修改用户时候，不再显示密码

```js
// 结构
 <el-form-item v-if="!user.id" label="用户密码" prop="password">
          <el-input v-model="user.password" />
        </el-form-item>
// 行为--展示对话框，具体逻辑在对话框里处理
showUpdateUser(user) {
     // 深克隆拷贝，开辟新的内存地址，两者互不影响，便于对话框显示用户信息
      this.user = cloneDeep(user)
      this.dialogUserVisible = true
    },
```

（4）删除用户

```js
// 删除某个用户
    async removeUser(id) {
      await this.$API.user.removeById(id)
      this.$message.success('删除成功')
      this.getUsers(this.users.length === 1 ? this.page - 1 : this.page)
    },
    
// 删除用户接口
export function removeById(id) {
  return request({
    url: `${api_name}/remove/${id}`,
    method: 'delete'
  })
}
```

#### 4.用户信息table分配角色

分配角色按钮+对话框的静态结构，点击分配角色按钮的时候需要做的事情：知道点击的哪个用户，让对话框显示出来并获取用户的角色数据；

对话框出来的时候要做的事情：将当前用户的角色数据展示出来，动态控制全选框的属性值`checkAll`，双向绑定，但全选看是否选中的属性值`isIndeterminate`，为单向数据绑定，关闭或取消都需要将当前的数据重置`resetRoleData`，如果每个复选框的勾选状态变化时，都会触发`handleCheckedChange`，修改复选框的是否选中。如果用户点击取消或关闭会触发`resetRoleData`

（1）对话框静态结构

```js
 <HintButton type="info" size="mini" icon="el-icon-user-solid"
            title="分配角色"  @click="showAssignRole(row)" />
            
<!-- 分配角色的对话框的结构,关闭前重置数据 -->
    <el-dialog title="分配角色" :visible.sync="dialogRoleVisible" :before-close="resetRoleData">
      <el-form label-width="80px">
        <!-- 用户名文本框，默认不可用 -->
        <el-form-item label="用户名">
          <el-input disabled :value="user.username" />
        </el-form-item>
        <el-form-item label="角色列表">
          <!-- 全选框 -->
          <el-checkbox v-model="checkAll"  :indeterminate="isIndeterminate" @change="handleCheckAllChange">全选</el-checkbox>
          <!-- 复选框数据 -->
          <el-checkbox-group v-model="userRoleIds" @change="handleCheckedChange" >
            <!-- 遍历所有角色列表生成多个复选框 -->
            <el-checkbox v-for="role in allRoles" :key="role.id" :label="role.id"
              >{{ role.roleName }}</el-checkbox >
          </el-checkbox-group>
        </el-form-item>
      </el-form>
      <!-- 底部按钮 -->
      <div slot="footer">
        <el-button :loading="loading" type="primary" @click="assignRole">保存</el-button >
        <el-button @click="resetRoleData">取消</el-button>
      </div>
    </el-dialog> 
```

（2）获取用户角色列表的回调

```js
// 分配角色按钮-----显示指定角色的界面
    showAssignRole(user) {
      // 获取当前要操作的user
      this.user = user
      this.dialogRoleVisible = true
      // 获取用户的角色列表 
      this.getRoles()
    },
// 异步获取用户的角色列表        
    async getRoles() {
      const result = await this.$API.user.getRoles(this.user.id)
      const { allRolesList, assignRoles } = result.data
      // 所有角色列表
      this.allRoles = allRolesList
      // 当前用户的角色ID的列表，后台方便根据id去做更新
      this.userRoleIds = assignRoles.map((item) => item.id)
       // 所有角色的数组长度等于当前用户的角色的数组长度时全选框选中
      this.checkAll = allRolesList.length === assignRoles.length
       // 控制复选框非全选的属性，只有勾选数量大于0且不是全选的时候，才会为true 
      this.isIndeterminate =
        assignRoles.length > 0 && assignRoles.length < allRolesList.length
    },
 
// 获取某个用户的所有角色
export function getRoles(userId) {
  return request({
    url: `${api_name}/toAssign/${userId}`,
    method: 'get'
  })
}
```

（3）全选框和复选框改变时的回调 

```js
// 全选勾选状态发生改变的监听
    handleCheckAllChange(value) {
      // value 当前勾选状态true/false
      // 如果当前全选, userRoleIds就是所有角色id的数组, 否则是空数组
      this.userRoleIds = value ? this.allRoles.map((item) => item.id) : []
      // 如果当前不是全选也不全不选时, 指定为false
      this.isIndeterminate = false
    },
    
// 复选框角色列表选中项发生改变的监听
    handleCheckedChange(value) {
      // 用户的角色ID的列表和全部角色列表
      const { userRoleIds, allRoles } = this
      // 当两者相等且长度大于0时默认全选
      this.checkAll =
        userRoleIds.length === allRoles.length && allRoles.length > 0
      // 当全部角色的数据大于用户且用户选中的大于0，则复选框为选中状态但不是全选
      this.isIndeterminate =
        userRoleIds.length > 0 && userRoleIds.length < allRoles.length
    }, 
```

（4）对话框保存及取消回调

```js
 // 请求给用户进行角色授权
    async assignRole() {
      const userId = this.user.id
      const roleIds = this.userRoleIds.join(',')
      // 开始loading
      this.loading = true
      const result = await this.$API.user.assignRoles(userId, roleIds)
      // 结果回来loadin结束
      this.loading = false
      this.$message.success(result.message || '分配角色成功')
       // 关闭对话框
      this.dialogRoleVisible = false
      if (this.$store.getters.name === this.user.username) {
        window.location.reload()
      }
    },

// 重置用户角色的数据---让所有数据都清空，方便下次在进入时重新去获取
    resetRoleData() {
      this.dialogRoleVisible = false
      this.allRoles = []
      this.userRoleIds = []
      this.isIndeterminate = false
      this.checkAll = false
    },
```

## 11、权限管理之角色管理

#### 1.获取角色信息

```js
/*异步获取角色分页列表--组件挂载就获取一次*/
    getRoles(page = 1) {
      this.page = page
      // 开始loading效果
      this.listLoading = true
      // searchObj:发送请求的条件参数数据
      const { limit, searchObj } = this
      this.$API.role.getPageList(page, limit, searchObj).then((result) => {
          const { items, total } = result.data
          // 重新给角色列表 roles 赋值
          this.roles = items.map((item) => {
            item.edit = false // 用于标识是否显示编辑输入框的属性
            item.originRoleName = item.roleName // 缓存角色名称, 如果用户点击取消则还是用旧的originRoleName
            return item
          })
          // 总条数
          this.total = total
        }).finally(() => {
          this.listLoading = false
        })
    },
```

#### 2.查询角色

```js
 <el-button @click="search" >查询</el-button>

/*根据搜索条件进行搜索*/
    search() {
      // 将收集搜索条件数据的对象赋值发送请求的条件参数数据，这样两者相互是不影响的 
      this.searchObj = { ...this.tempSearchObj }
      this.getRoles()
    },
```

#### 3.清空输入

```js
<el-button style="margin-top: 20px" @click="resetSearch">清空</el-button>

/*重置查询表单搜索列表*/
    resetSearch() {
      // 清空输入框内已有的内容
      this.tempSearchObj = {   roleName: ''}
      // 发请求是带着 searchObj 去的，所以需要清空本次的，否则就会影响再次请求
      this.searchObj = { roleName: '' }
      this.getRoles()
    },
```

#### 4.添加角色

```js
<el-button type="primary" @click="addRole">添加</el-button>

// 添加角色
 addRole() {
      // 可输入弹框----显示添加界面
     // 用法：$prompt(message, title, options)  其中title可省略	
      this.$prompt('请输入新名称', '添加角色', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
      }).then(({ value }) => {
          // 发请求保存新角色，value就是用户输入的数据
          this.$API.role.save({ roleName: value }).then((result) => {
            // 保存成功提示 
            this.$message.success(result.message || '添加角色成功')
            this.getRoles()
          })
        })
        .catch(() => {
          this.$message.warning('取消添加')
        })
    },
```

#### 4.批量删除角色

```js
// 没有选中数据时，此按钮不能使用 
<el-button type="danger" :disabled="selectedRoles.length === 0"
        @click="removeRoles()" >批量删除</el-button>

/*批量删除*/
    removeRoles() {
      this.$confirm('此操作将永久删除该记录, 是否继续?', '提示', {
        type: 'warning',
      }).then(async () => {
          const ids = this.selectedRoles.map((role) => role.id)
          const result = await this.$API.role.removeRoles(ids)
          this.getRoles()
          this.$message({
            type: 'success',
            message: '批量删除成功!',
          })
        }).then((result) => {}).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除',
          })
        })
    },
```

#### 5.table之分配权限

```js
 <HintButton  size="mini"  type="info" icon="el-icon-info"
    title="分配权限"  @click=" $router.push(`/acl/role/auth/${row.id}?roleName=${row.roleName}`) "/>    
```

#### 6.table之修改角色

当点击修改角色时，将edit修改为true，角色名称改为`可编辑的输入框+取消按钮`

```js
 <!-- 当修改角色时会出现 -->
  <HintButton v-if="!row.edit" size="mini" type="primary"
    icon="el-icon-edit" title="修改角色"  @click="row.edit = true" />
          
<el-table-column label="角色名称">
        <template slot-scope="{ row }">
          <template v-if="row.edit">
            <el-input v-model="row.roleName" class="edit-input" size="small" />
            <el-button
              class="cancel-btn"
              size="small"
              icon="el-icon-refresh"
              type="warning"
              @click="cancelEdit(row)"
            >
              取消
            </el-button>
          </template>
          <span v-else>{{ row.roleName }}</span>
        </template>
      </el-table-column>  

// 取消修改角色
  cancelEdit(role) {
      // 将原来的值重新赋值
      role.roleName = role.originRoleName
      // edit状态改为假，就不显示输入框和取消按钮了
      role.edit = false
      this.$message.warning('取消角色修改')
    },
```

#### 7.删除选中的角色

```js
 <HintButton  size="mini" type="danger" icon="el-icon-delete"
            title="删除角色" @click="removeRole(row)"/>
            
 // 删除指定的角色
    removeRole({ id, roleName }) {
      this.$confirm(`确定删除 '${roleName}' 吗?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      })
        .then(async () => {
          // 发请求删除角色
          const result = await this.$API.role.removeById(id)
          // 重新发请求需要携带page，因为是删除用户
          this.getRoles(this.roles.length === 1 ? this.page - 1 : this.page)
          this.$message.success(result.message || '删除成功!')
        })
        .catch(() => {
          this.$message.info('已取消删除')
        })
    },
```

#### 8.分配权限的树形控件

获取所有权限的列表进行展示，created钩子获取当前用户的权限，将当前用户拥有的权限默认选中，保存的时候，取消的话直接跳转回原来的路由Role即可

```js
<el-input disabled :value="$route.query.roleName" />
    <el-tree
      ref="tree"
      style="margin: 20px 0"
      :data="allPermissions"
      node-key="id"
      show-checkbox
      default-expand-all
      :props="defaultProps"
    />
    <el-button :loading="loading" type="primary" @click="save">保存</el-button>
    <el-button @click="$router.replace({ name: 'Role' })">取消</el-button>
```

（1）获取全部权限的数据

```js
/*
      初始化
      */
    init() {
      const roleId = this.$route.params.id
      this.getPermissions(roleId)
    },

    /*
      获取指定角色的权限列表
      */
    getPermissions(roleId) {
      this.$API.permission.toAssign(roleId).then((result) => {
        const allPermissions = result.data.children
        // 保存所有权限
        this.allPermissions = allPermissions
        // 获取所有权限中被选中的权限
        const checkedIds = this.getCheckedIds(allPermissions)
        // 设置为选中状态
        this.$refs.tree.setCheckedKeys(checkedIds)
      })
    },
```

（2）获取选中的id列表

```js
 /*得到所有选中的id列表*/
    getCheckedIds(auths, initArr = []) {
      return auths.reduce((pre, item) => {
        // 被选中且level为4，说明就是最小层级了
        if (item.select && item.level === 4) {
          pre.push(item.id)
        } else if (item.children) {
          // 如果有孩子，就可以继续使用此方法去获取最小层级被选中的id数据
          this.getCheckedIds(item.children, initArr)
        }
        return pre
      }, initArr)
    },
```

（3）保存权限列表

```js
save() {
      var ids = this.$refs.tree.getCheckedKeys().join(',')
      /*
        vue elementUI tree树形控件获取父节点ID的实例
        修改源码:
        情况1: element-ui没有实现按需引入打包,
          node_modules\element-ui\lib\element-ui.common.js    25382行修改源码  去掉 'includeHalfChecked &&'
          // if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          if ((child.checked || child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
        情况2: element-ui实现了按需引入打包
          node_modules\element-ui\lib\tree.js    1051行修改源码  去掉 'includeHalfChecked &&'
          // if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          if ((child.checked || child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
        */
      this.loading = true
      this.$API.permission
        .doAssign(this.$route.params.id, ids)
        .then((result) => {
          this.loading = false
          this.$message.success(result.$message || '分配权限成功')
          // 必须在跳转前获取(跳转后通过this获取不到正确的数据了)--当前用户的角色名称
          const roleName = this.$route.query.roleName
          // 全部角色列表数据
          const roles = this.$store.getters.roles
          this.$router.replace('/acl/role/list', () => {
            // 跳转成功后, 判断如果更新的是当前用户对应角色的权限, 重新加载页面以获得最新的数据
            if (roles.includes(roleName)) {
              window.location.reload()
            }
          })
        })
    },
```

## 12、权限管理之菜单管理

#### 1.表格数据

```js
/*
    请求获取权限菜单数据列表
    */
   async fetchPermissionList() {
      // 发请求
      const result = await this.$API.permission.getPermissionList()
      // 保存列表权限数据
      this.menuPermissionList = result.data.children
      console.log(this.menuPermissionList)
      // 数组只有一个数组，索引值为0，里面是个对象
      this.expandKeys = [this.menuPermissionList[0].id]
    },

```

#### 2.校验规则

```js
// 菜单权限校验的规则
const menuRules = {
  name: [{ required: true, message: '名称必须输入' }],
  code: [{ required: true, message: '权限值必须输入' }],
}

// 按钮功能权限校验的规则
const btnRules = {
  name: [{ required: true, message: '名称必须输入' }],
  code: [{ required: true, trigger: 'blur', message: '功能权限值必须输入' }],
}
```

#### 3.添加菜单

如果有id就是修改功能，没有id就是新增功能，然后根据点击的level确定对应的菜单|功能的级别

本身是一级===> 添加的就是一级菜单（可展开）

本身是二级===> 添加的就是二级菜单（可展开）

而三级只能添加功能了，不能再展开

```js
<HintButton
            :disabled="row.level === 4"
            type="primary"
            icon="el-icon-plus"
            size="mini"
            :title="getAddTitle(row.level)"
            @click="toAddPermission(row)"
          />
 /*
    根据级别得到要显示的添加按钮的提示文字
    */
    getAddTitle(level) {
      if (level === 1 || level === 2) {
        return '添加菜单'
      } else if (level === 3) {
        return '添加功能'
      }
    },

/*显示添加权限的界面(菜单或功能)*/
    toAddPermission(row) {
      // 显示对话框
      this.dialogPermissionVisible = true
      // 要操作的菜单权限对象的id
      this.permission.id = row.id
      // 添加的肯定是比自己大一级的权限
      this.permission.level = row.level + 1
      this.permission.type = this.permission.level === 4 ? 2 : 1
      this.permission.pname = row.name // 用于显示父名称, 但提交请求时是不需要的

      // 清除校验(必须在界面更新之后)
      this.$nextTick(() => this.$refs.permission.clearValidate())
    },        
```

#### 4.添加菜单对话框

```js
<!-- 添加菜单对话框 -->
    <el-dialog
      :visible.sync="dialogPermissionVisible"
      :title="dialogTitle"
      @close="resetData"
    >
      <el-form
        ref="permission"
        :model="permission"
        :rules="permissionRules"
        label-width="120px"
      >
        <el-form-item
          v-if="permission.level > 2 && !permission.id"
          label="父级名称"
        >
          <el-input :value="permission.pname" disabled />
        </el-form-item>
        <el-form-item label="名称" prop="name">
          <el-input v-model="permission.name" />
        </el-form-item>

        <el-form-item label="功能权限值" prop="code">
          <el-input v-model="permission.code" />
        </el-form-item>

        <el-form-item
          v-if="permission.level === 4"
          label="跳转路由权限值"
          prop="toCode"
        >
          <el-input v-model="permission.toCode" />
        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button @click="resetData">取 消</el-button>
        <el-button type="primary" @click="addOrUpdatePermission"
          >确 定</el-button
        >
      </div>
    </el-dialog>

/*
    动态计算得到添加|修改对话框Dialog的标题
    */
    dialogTitle() {
      const { name, level } = this.permission
      // 通过name即名称是否存在，进行添加和修改的区分
      if (!name) {
        // 添加
        return level === 4
          ? '添加功能'
          : `添加${level === 2 ? '一级' : '二级'}菜单`
      } else {
        // 修改
        console.log(level)
        return level === 4 ? '修改功能' : '修改菜单'
      }
    },
```

#### 5.添加菜单对话框确定回调

```js
/*添加或更新功能权限*/
    addOrUpdatePermission() {
      this.$refs.permission.validate(async (valid) => {
         // 验证成功
        if (valid) {
          const { pname, ...perm } = this.permission // pname不需要携带
          // 有id就走更新，没有id就走添加
          const result = await this.$API.permission[
            perm.id ? 'updatePermission' : 'addPermission'
          ](perm)
          this.$message.success(
            result.message || `${perm.id ? '修改' : '添加'}成功!`
          )
            // 重置数据
          this.resetData()
            // 请求获取权限菜单数据列表
          this.fetchPermissionList()
        }
      })
    },
```

#### 6.添加菜单对话框取消回调

```js
/*重置数据 */
    resetData() {
        // 关闭对话框
      this.dialogPermissionVisible = false
        // 清空数据
      this.permission = {
        level: 0,
        name: '',
        code: '',
        toCode: '',
      }
    },
```

#### 7.修改菜单|功能

```js
 <HintButton
            type="primary"
            icon="el-icon-edit"
            size="mini"
            :disabled="row.level === 1"
            :title="row.level === 4 ? '修改功能' : '修改菜单'"
            @click="toUpdatePermission(row)"
          />
                
/*显示菜单添加或更新的dialog*/
    toUpdatePermission(row) {
     // 和添加用的是同一个对话框，通过id进行区分，先将对话框显示出来，具体逻辑会在对话框内处理
      this.dialogPermissionVisible = true
      this.permission = { ...row } // 使用浅拷贝,内容地址都一样
      this.permission.type = this.permission.level === 4 ? 2 : 1

      // 清除校验(必须在界面更新之后)
      this.$nextTick(() => this.$refs.permission.clearValidate())
    },
```

#### 8.删除菜单|功能

```js
 <HintButton
            :disabled="row.level === 1"
            type="danger"
            icon="el-icon-delete"
            size="mini"
            title="删除"
            @click="removePermission(row)"
          />

/*删除某个权限节点*/
    removePermission(permission) {
      this.$confirm('此操作将永久删除该记录, 是否继续?', '提示', {
        type: 'warning',
        confirmButtonText: '确定',
        cancelButtonText: '取消',
      })
        .then(async () => {
          // 发请求通过id删除此权限
          const result = await this.$API.permission.removePermission(
            permission.id
          )
          // 提示
          this.$message.success(result.message || '删除成功!')
          //删除成功重新获取数据
          this.fetchPermissionList()
        })
        .catch((error) => {
          if (error === 'cancel') {
            this.$message({
              type: 'info',
              message: '已取消删除',
            })
          }
        })
    },
```



## 13、菜单和权限按钮

#### 1.路由规划

为了实现不同用户登录项目后展示的内容不同，就需要将路由写成活得，可以动态展示不同的权限内容，这里可以将路由分成：常量路由（谁都能看），异步路由（有权限的才能看），错误路由即404路由，然后只需要对异步路由进行权限配置即可

```js
// 路由的配置：为什么不同用户登录我们的项目，菜单显示都是一样的
// 因为目前的路由是死的，不管是哪个用户，能看见的，操作的都是一样
// 需要把项目中的路由进行拆分

// 常量路由：不管用户什么角色都可以看见的路由，没有权限区分
//  不管什么角色，都能看到登录，首页和404路由
export const constantRoutes = [{
  path: '/login',
  component: () => import('@/views/login/index'),
  // 不在菜单栏展示
  hidden: true
},
{
  path: '/404',
  component: () => import('@/views/404'),
  hidden: true
},
{
  path: '/',
  component: Layout,
  redirect: '/dashboard',
  children: [{
    path: 'dashboard',
    name: 'Dashboard',
    component: () => import('@/views/dashboard/index'),
    // 设置在侧边栏展示的文字
    meta: {
      title: '首页',
      icon: 'dashboard'
    }
  }]
}
]
// 异步路由：不同的用户(角色)，需要过滤筛选出的路由，称为异步路由
export const asyncRoutes = [
  {
    name: 'Acl',
    path: '/acl',
    component: Layout,
    redirect: '/acl/user/list',
    meta: {
      title: '权限管理',
      icon: 'el-icon-setting'
    },
    children: [
      {
        name: 'User',
        path: 'user/list',
        component: () => import('@/views/acl/user/list'),
        meta: {
          title: '用户管理'
        }
      },
      {
        name: 'Role',
        path: 'role/list',
        component: () => import('@/views/acl/role/list'),
        meta: {
          title: '角色管理'
        }
      },
      {
        name: 'RoleAuth',
        path: 'role/auth/:id',
        component: () => import('@/views/acl/role/roleAuth'),
        meta: {
          activeMenu: '/acl/role/list',
          title: '角色授权'
        },
        hidden: true
      },
      {
        name: 'Permission',
        path: 'permission/list',
        component: () => import('@/views/acl/permission/list'),
        meta: {
          title: '菜单管理'
        }
      }
    ]
  },
  {
    path: '/product',
    component: Layout,
    name: 'Product',
    meta: { title: '商品管理', icon: 'el-icon-goods' },
    children: [
      {
        path: 'trademark',
        name: 'TradeMark',
        component: () => import('@/views/product/tradeMark'),
        meta: { title: '品牌管理' }
      },
      {
        path: 'attr',
        name: 'Attr',
        component: () => import('@/views/product/Attr'),
        meta: { title: '平台属性管理' }
      },
      {
        path: 'spu',
        name: 'Spu',
        component: () => import('@/views/product/Spu'),
        meta: { title: 'Spu管理' }
      },
      {
        path: 'sku',
        name: 'Sku',
        component: () => import('@/views/product/Sku'),
        meta: { title: 'Sku管理' }
      }
    ]
  }
    
    
 
// 当路径出现错误的时候重定向至404
export const anyRoutes = [
  // 404 页面必须在最后
  { path: '*', redirect: '/404', hidden: true }
]
```

#### 2.菜单权限

菜单权限：当用户获取用户信息的时候，服务器会把相应的用户拥有的菜单的权限信息返回，需要根据用户身份对比出，当前这个用户需要展示哪些菜单

- 超级管理员：首页、权限、商品都能操作
- 硅谷321：首页

如果实现菜单的权限？不同用户所能操作|查看的菜单是不一样的？

不同的用户登录的时候会向服务器发请求，会把用户相应的菜单的权限信息返回回来，可以根据服务器返回的信息，动态的设置路由，	，两个都是数组进行比较筛选后展示即可

（1）vuex-user.js计算出用户需要展示的异步路由

```js
// 路由模块当中重置路由的方法
import { resetRouter, asyncRoutes, anyRoutes, constantRoutes } from '@/router'
// 引入路由
import router from '@/router'


const actions={
	// 获取用户信息
  getInfo({ commit, state }) {
    return new Promise((resolve, reject) => {
      getInfo(state.token).then(response => {
        // 获取用户信息：返回的数据包含：用户名name 用户头像 avatar routes[返回的标志：不同的用户应该展示哪些菜单的标记]
        // roles[用户角色信息] buttons[按钮的信息：按钮权限用户的标记]
        const { data } = response
        // vuex存储用户全部的信息
        commit('SET_USERINFO', data)
        // 提交mutations时候，计算用户应该展示的异步路由
        commit('SET_RESULTASYNCROUTES', computedAsyncRoutes(asyncRoutes, data.routes))
        resolve(data)
      }).catch(error => {
        reject(error)
      })
    })
  },
}


const mutations={
  // 最终计算出来的异步路由+其他路由
  SET_RESULTASYNCROUTES: (state, asyncRoutes) => {
    // vuex保存当前用户的异步路由，注意一个用户需要展示完成路由：常量，异步，任意路由
    state.resultAsyncRoutes = asyncRoutes
    // 计算出当前用户需要展示所有路由,全部连接后再赋值
    state.resultAllRoutes = constantRoutes.concat(state.resultAsyncRoutes, anyRoutes)
    // 给路由器添加新的路由
    router.addRoutes(state.resultAllRoutes)
  }
}


// 定义函数：两个数组进行对比，对比出当前用户到底显示哪些异步路由
const computedAsyncRoutes = (asyncRoutes, routes) => {
  // 两个数组取交集
  // 过滤出当前用户【超级管理|普通员工】需要展示的异步路由
  return asyncRoutes.filter(item => {
    // 不等于-1代表有这个元素
    if (routes.indexOf(item.name) !== -1) {
      // 递归,还有二级，三级等路由
      if (item.children && item.children.length) {
        item.children = computedAsyncRoutes(item.children, routes)
      }
      return true
    }
  })
}
```

（2）layout-components-sideMenu中的修改遍历的路由数组，就完成了不同用户展示不同菜单权限的效果

```js
 <sidebar-item
          v-for="route in routes"
          :key="route.path"
          :item="route"
          :base-path="route.path"
        />
        
// 应该替换为vuex中计算好的全部路由
    routes() {
      // 这里遍历的是常量路由的数组
      // 需要遍历的应该是仓库计算完毕的全部路由
      return this.$store.state.user.resultAllRoutes
      // return this.$router.options.routes
    }, 
```

#### 3.按钮权限

不同的用户（角色），有的用户是可见按钮，有的是不可见

http://localhost:9528/dev-api/admin/acl/role/batchRemove

http://localhost:9528/dev-api/admin/acl/role/remove/1555083039878062082

http://localhost:9528/dev-api/admin/acl/role/1/5?roleName=

["1555083039878062082"]

​    

把login中的loginRules注释掉，就可以用其他账号登录了

